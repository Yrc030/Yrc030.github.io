<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>redis学习笔记 | 庸人冲的个人博客</title><meta name="keywords" content="笔记,redis"><meta name="author" content="庸人冲"><meta name="copyright" content="庸人冲"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis概述和安装概述 Redis是一个开源的key-value存储系统。 Redis支持存储的value类型：string、list、set、zset（sorted set）、hash… 这些数据类型都支持push&#x2F;pop、add&#x2F;remove、交集、并集和差集等操作，这些操作都是原子性的。   Redis支持各种不同方式的排序。  Redis中的数据都缓存在内存中，提高效率。 Redis会周">
<meta property="og:type" content="article">
<meta property="og:title" content="redis学习笔记">
<meta property="og:url" content="https://yrc030.github.io/posts/390cb8c9/index.html">
<meta property="og:site_name" content="庸人冲的个人博客">
<meta property="og:description" content="Redis概述和安装概述 Redis是一个开源的key-value存储系统。 Redis支持存储的value类型：string、list、set、zset（sorted set）、hash… 这些数据类型都支持push&#x2F;pop、add&#x2F;remove、交集、并集和差集等操作，这些操作都是原子性的。   Redis支持各种不同方式的排序。  Redis中的数据都缓存在内存中，提高效率。 Redis会周">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg">
<meta property="article:published_time" content="2021-07-27T16:00:00.000Z">
<meta property="article:modified_time" content="2022-09-06T03:02:04.462Z">
<meta property="article:author" content="庸人冲">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://yrc030.github.io/posts/390cb8c9/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/manifest.json"/><meta name="msapplication-TileColor" content="#49b1f5"/><link rel="apple-touch-icon" sizes="180x180" href="/icons/icon-128x128.png"/><link rel="icon" type="image/png" sizes="32x32" href="/icons/icon-16x16.png"/><link rel="icon" type="image/png" sizes="16x16" href="/icons/icon-32x32.pmg"/><link rel="mask-icon" href="/icons/icon-128x128.png" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 庸人冲","link":"链接: ","source":"来源: 庸人冲的个人博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'redis学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-09-06 11:02:04'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://cdn.cbd.int/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="庸人冲的个人博客" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-music"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">庸人冲的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-music"></i><span> 图库</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">redis学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-27T16:00:00.000Z" title="发表于 2021-07-28 00:00:00">2021-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-09-06T03:02:04.462Z" title="更新于 2022-09-06 11:02:04">2022-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>124分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="redis学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis概述和安装"><a href="#Redis概述和安装" class="headerlink" title="Redis概述和安装"></a>Redis概述和安装</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>Redis是一个开源的<strong>key-value</strong>存储系统。</li>
<li>Redis支持存储的<strong>value</strong>类型：<strong>string</strong>、<strong>list</strong>、<strong>set</strong>、<strong>zset</strong>（sorted set）、<strong>hash</strong>…</li>
<li><p>这些数据类型都支持<strong>push/pop</strong>、<strong>add/remove</strong>、<strong>交集</strong>、<strong>并集</strong>和<strong>差集</strong>等操作，这些操作都是<strong>原子性</strong>的。 </p>
</li>
<li><p>Redis支持各种不同方式的<strong>排序</strong>。</p>
</li>
<li>Redis中的数据都<strong>缓存在内存</strong>中，提高效率。</li>
<li>Redis会<strong>周期性</strong>的把更新的数据<strong>写入磁盘</strong>或者把修改操作写入追加的日志文件。</li>
<li>Redis实现了<strong>master-slave(主从)同步</strong>。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Redis安装到Linux系统中，官网下载Redis最新安装包，上传至Linux平台。</p>
<ol>
<li><p>安装gcc </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc --version # 查看gcc 是否安装</span><br><span class="line">yum install gcc # 如果没有安装, 执行指令安装</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压Redis安装包</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>cd 到解压目录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.6/</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242306459.png" alt="image-20220120125531749"></p>
</li>
<li><p>编译解压文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make </span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242306120.png" alt="image-20220120125805465"></p>
</li>
<li><p>安装Redis</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242306842.png" alt="image-20220120130506868"></p>
</li>
<li><p>切换到安装目录 /usr/local/bin/</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin</span><br><span class="line">ls </span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307485.png" alt="image-20220120130637075"></p>
</li>
</ol>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>前台启动（不推荐）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装目录下运行 redis-server</span></span><br><span class="line">redis-server</span><br></pre></td></tr></table></figure>
<p>启动后前台shell被占用，不能执行其它操作。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307713.png" alt="image-20220120130841676"></p>
<p><strong>后台启动（推荐）</strong></p>
<ol>
<li><p>备份解压文件夹下的 redis.conf 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/test/redis/redis-6.2.6/  </span><br><span class="line">ls</span><br><span class="line">mkdir -p  ~/test/copy/redis/ 		#  创建存放备份的文件夹</span><br><span class="line">cp redis.conf  ~/test/copy/redis/  # 将redis.conf拷贝至该文件夹下</span><br><span class="line">ls ~/test/copy/redis/					  # 查看拷贝是否成功</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307321.png" alt="image-20220120132025860"></p>
</li>
<li><p>设置支持后台启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改拷贝后的 redis.conf 文件</span></span><br><span class="line">cd ~/test/copy/redis/	</span><br><span class="line">vim redis.conf</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 daemonize no 改为 <span class="built_in">yes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">vim命令模式下输入:  /关键字 可以快速定位</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">:wq 保存退出</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   <img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307108.png" alt="image-20220120132337223"></p>
<ol>
<li><p>后台启动</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/bin/  # 切换到Redis安装路径下</span><br><span class="line">redis-server ~/test/copy/redis/redis.conf  # 启动redis-server程序, 并在后面执行修改后配置文件的路径</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看后台启动是否成功</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307450.png" alt="image-20220120132907686"></p>
</li>
<li><p>通过客户端连接redis</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307795.png" alt="image-20220120133005142"></p>
</li>
<li><p>退出到shell（不关闭）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ol>
<li><p>方式一：单实例关闭</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接redis后输入shutdown命令</span></span><br><span class="line">127.0.0.1:6379&gt; shutdown</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307729.png" alt="image-20220120133223716"></p>
</li>
<li><p>方式二：多实例关闭</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">指定端口号关闭</span></span><br><span class="line">redis-cli -p 6379 shutdown</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307790.png" alt="image-20220120133527246"></p>
</li>
<li><p>方式三：杀死进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis # 查看进程号</span><br><span class="line">kill -9 进程号</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307730.png" alt="image-20220120133802308"></p>
</li>
</ol>
<h2 id="Redis相关知识"><a href="#Redis相关知识" class="headerlink" title="Redis相关知识"></a>Redis相关知识</h2><h3 id="默认库及相关指令"><a href="#默认库及相关指令" class="headerlink" title="默认库及相关指令"></a>默认库及相关指令</h3><p>Redis默认端口号 <strong>6379</strong></p>
<p>Redis默认提供了<strong>16</strong>个数据库，类似数组下标从0开始，<strong>初始默认使用0号库</strong>。 </p>
<ul>
<li><p>切换数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">0.</span>.<span class="number">.15</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307346.png" alt="image-20220120134628782"></p>
<ul>
<li><p>查看当前数据库的 key 数量</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dbsize</span><br></pre></td></tr></table></figure>
</li>
<li><p>清空当前库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushdb</span><br></pre></td></tr></table></figure>
</li>
<li><p>通杀全部库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flushall </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="单线程-多路IO复用技术"><a href="#单线程-多路IO复用技术" class="headerlink" title="单线程 + 多路IO复用技术"></a>单线程 + 多路IO复用技术</h3><p>Redis是单线程+多路IO复用技术</p>
<ul>
<li><p>多路复用</p>
<blockquote>
<p>是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回。否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如线程池）。</p>
</blockquote>
</li>
</ul>
<h1 id="Key相关命令"><a href="#Key相关命令" class="headerlink" title="Key相关命令"></a>Key相关命令</h1><ul>
<li><p><strong><code>keys *</code></strong> ：查看当前库所有 key（匹配：keys *1）</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307894.png" alt="image-20220225170605834"></p>
</li>
</ul>
<ul>
<li><p><strong><code>exsits key</code></strong>：判断指定的 key 是否存在（1 表示存在，0 表示不存在）</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307442.png" alt="image-20220225170821238"></p>
</li>
</ul>
<ul>
<li><p><strong><code>type key</code></strong>：查看指定 key 的类型</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307852.png" alt="image-20220225170932338"></p>
</li>
</ul>
<ul>
<li><p><strong><code>del key</code></strong>：删除指定 key 的数据，<strong>直接删除</strong>。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307863.png" alt="image-20220225171231246"></p>
</li>
</ul>
<ul>
<li><p><strong><code>unlink key</code></strong>：<strong>根据 value 选择非阻塞删除，后续异步删除</strong></p>
<p><strong>unlink 命名仅将 keys 从 keyspace 元数据删除，真正的删除会在后续异步操作。</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242307802.png" alt="image-20220225171311137"></p>
</li>
</ul>
<ul>
<li><p><strong><code>expire key N</code></strong>：给指定的 key 设置过期时间（单位：秒）</p>
</li>
<li><p><strong><code>ttl key</code></strong>：查看指定 key 的过期时间（单位：秒），-1 表示永不过期，-2表示已过期</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308103.png" alt="image-20220225171740522"></p>
</li>
</ul>
<p>  如果未设置过期时间，key 的 ttl 默认为 -1（永不过期）</p>
<p>  <img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308763.png" alt="image-20220225172028788"></p>
<h1 id="常用五大数据类型"><a href="#常用五大数据类型" class="headerlink" title="常用五大数据类型"></a>常用五大数据类型</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>String 是 Redis 最基本的类型，一个 key 对应一个 value。</li>
<li>String类型是<strong>二进制安全的</strong>，意味着 Redis 的 String 可以包含任何数据。比如， jpg 图片、序列化的对象…</li>
<li>一个 Redis 中 String 类型的 value 值最大容量是 <strong>512M</strong>。</li>
</ul>
<p><strong>字符串底层数据结构</strong></p>
<ul>
<li>简单动态字符串（Simple Dynamic String），可修改的字符串，类似于 Java 中的 ArrayList，采取冗余空间的方式。</li>
<li>当字符串长度 &gt; 实际分配内存空间时，进行扩容：<ul>
<li>字符串长度小于 1M 时，两倍扩容。</li>
<li>字符串长度大于 1M 时，每次扩容 1 M空间。</li>
<li>字符串长度最多 512M。</li>
</ul>
</li>
</ul>
<p><strong>原子操作</strong>：不会被先出调度机制打断的操作。</p>
<ul>
<li>这种操作一旦开始，就一直允许到结束，中间不会有任何 context switch （上下文切换）</li>
<li>在单线程中，<strong>能够在单条指令中完成的操作</strong>都可以认为是<strong>原子操作</strong>，因为中断只能发生于指令之间。</li>
<li>在多线程中，不能被其它进程（线程）打断的操作叫原子操作。</li>
<li>Redis 单命令的原子性主要得益于 Redis 的单线程。</li>
</ul>
<h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>set key value</code></strong>：向数据库中添加一个键值对，<strong>重复的 key 的 value 将被覆盖</strong>。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308851.png" alt="image-20220225172739023"></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308749.png" alt="image-20220225172951212"></p>
</li>
</ul>
<ul>
<li><p><strong><code>setnx key value</code></strong>：向数据库中添加一对键值对，<strong>不会覆盖重复 key 的 value。</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308996.png" alt="image-20220225173644505"></p>
</li>
</ul>
<ul>
<li><p><strong><code>get key</code></strong>：获取指定 key 的 value</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308077.png" alt="image-20220225172820704"></p>
</li>
</ul>
<ul>
<li><p><strong><code>append key value</code></strong>：对指定 key 的值进行追加，返回追加后字符串的长度。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242308957.png" alt="image-20220225173149838"></p>
</li>
</ul>
<ul>
<li><p><strong><code>strlen key</code></strong>：获取指定 key 映射的值的长度。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220225173228.png" alt="image-20220225173228077"></p>
</li>
</ul>
<ul>
<li><p><strong><code>incr key</code></strong>：对指定 key 映射的<strong>数字值</strong>加 1。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220225173846.png" alt="image-20220225173846174"></p>
</li>
</ul>
<ul>
<li><p><strong><code>decr key</code></strong>：对指定 key 映射的<strong>数字值</strong>减1。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220225174030.png" alt="image-20220225174030765"></p>
</li>
</ul>
<ul>
<li><p><strong><code>incrby / decrby &lt;key&gt; &lt;step&gt;</code></strong>：对指定 <key> 映射的<strong>数值增加或减少</strong> <step> </p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220225174319.png" alt="image-20220225174319578"></p>
</li>
<li><p><strong><code>mset &lt;k1&gt; &lt;v1&gt; &lt;k2&gt; &lt;v2&gt;...</code></strong>：同时设置一个或多个 k-v 对，<strong>重复的 key 的 value 将被覆盖</strong>。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228094017.png" alt="image-20220228094017788"></p>
</li>
<li><p><strong><code>mget &lt;k1&gt; &lt;k2&gt; &lt;k3&gt; ...</code></strong>：同时获取一个或多个 value 值</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228094028.png" alt="image-20220228094028935"></p>
</li>
<li><p><strong><code>msetnx &lt;k1&gt; &lt;v1&gt; ...</code></strong>：同时设置一个或多个 k - v对，<strong>设置的一组 k - v对中，只要有一个 key 重复，整个命令都不会执行成功</strong>。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228094559.png" alt="image-20220228094559513"></p>
</li>
</ul>
<p>  <img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228094636.png" alt="image-20220228094636207"></p>
<ul>
<li><p><strong><code>getrange</code> <key> [begin,end]</strong>：获取指定 key 所对应值的指定范围内的数据，前闭后闭。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228095010.png" alt="image-20220228095010161"></p>
</li>
<li><p><strong><code>setrange &lt;key&gt; &lt;offset&gt;&lt;value&gt;</code></strong>：设置指定 key 的从 offset 位置开始的值为 value。</p>
<p> <img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228095243.png" alt="image-20220228095242977"></p>
</li>
<li><p><strong><code>setex &lt;key&gt; &lt;seconds&gt; &lt;value&gt;</code></strong>：设置 k - v 对，并指定过期时间。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228095543.png" alt="image-20220228095543430"></p>
</li>
<li><p><strong><code>getset &lt;key&gt; &lt;value&gt;</code> </strong>：获取指定 key 的旧值，并同时设置新值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228095831.png" alt="image-20220228095831488"></p>
</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><strong>特点</strong>：</p>
<ul>
<li>单键多值。</li>
</ul>
<p><strong>底层数据结构</strong>：</p>
<ul>
<li><p>当<strong>元素较少</strong>时，使用<strong>一块连续的存储空间</strong>，结构为<strong>压缩列表</strong>（Zip List）。</p>
</li>
<li><p>当元素较多时，使用链表将多个连续的压缩列表链接起来，这种数据结构称作快速列表（Quick List）。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228104911.png" alt="image-20220228104911268"></p>
</li>
</ul>
<h3 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>lpush/rpush &lt;key&gt; &lt;value1 value2 value3...&gt;</code></strong>：从左边或右边依次插入一个或多个值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228101806.png" alt="image-20220228101806419"></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228101910.png" alt="image-20220228101910411"></p>
</li>
</ul>
<ul>
<li><p><strong><code>lrange &lt;key&gt; [begin,end]</code></strong>：获取指定 key [begin,end] 范围内的值。[0, -1] 表示取所有值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228102100.png" alt="image-20220228102100109"></p>
</li>
</ul>
<ul>
<li><p><strong><code>lpop/rpop</code></strong>：从指定 key 的列表左边或右边 pop 掉一个值，列表为空时，key 也会被删除。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228102442.png" alt="image-20220228102442674"></p>
</li>
</ul>
<ul>
<li><p><strong><code>rpoplpush</code> <key1> <key2></strong>：从 key1 列表的右边 pop 一个值，并 push 到 key2 列表的左边。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228102744.png" alt="image-20220228102744602"></p>
</li>
<li><p><strong><code>lindex &lt;key&gt; &lt;index&gt;</code></strong>：取得 key 列表中指定 index 位置上的值（从左至右）。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228103033.png" alt="image-20220228103033081"></p>
</li>
<li><p><strong><code>llen &lt;key&gt;</code></strong>：获取 key 链表的长度。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228103116.png" alt="image-20220228103116682"></p>
</li>
<li><p><strong><code>linsert &lt;key&gt; &lt;befroe|after&gt; &lt;value&gt; &lt;newValue&gt;</code></strong>：在 key 列表指定 value 值之前或之后插入 newValue。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228103611.png" alt="image-20220228103611090"></p>
</li>
<li><p><strong><code>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code></strong>：从左边删除 n 个 value 值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228104033.png" alt="image-20220228104033172"></p>
</li>
<li><p><strong>lset <key> <index> <value></strong>：将 key 列表 index 位置上的值替换为 value。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228104244.png" alt="image-20220228104244817"></p>
</li>
</ul>
<p>​    </p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p><strong>特点：</strong></p>
<ul>
<li>自动去重。</li>
<li>元素无序。</li>
<li>增、删、改、查的时间复杂度 O(1)。</li>
</ul>
<p><strong>数据结构：</strong></p>
<ul>
<li>value 为 null 的一个hash表。</li>
</ul>
<h3 id="常用指令-2"><a href="#常用指令-2" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>sadd &lt;key&gt; &lt;value1&gt; &lt;value2&gt;...</code></strong>：向 key 集合中添加一个或多个元素（无序）。</p>
</li>
<li><p><strong><code>smembers &lt;key&gt;</code></strong>：获取 key 集合中的所有元素（无序）。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228110351.png" alt="image-20220228110351409"></p>
</li>
<li><p><strong><code>sismember &lt;key&gt; &lt;value&gt;</code></strong>：判断 value 是否存在于 key 集合中。0 不存在，1 存在。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228110410.png" alt="image-20220228110410745"></p>
</li>
<li><p><strong><code>scard &lt;key&gt;</code></strong>：获取 key 集合元素的个数。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228110500.png" alt="image-20220228110500182"></p>
</li>
<li><p><strong><code>srem &lt;key&gt; &lt;value1&gt; ...</code></strong>：删除 key 集合中一个获取多个值。</p>
<p> <img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228110632.png" alt="image-20220228110632301"></p>
</li>
<li><p><strong><code>spop &lt;key&gt;</code></strong>：随机 pop 掉 key 集合中的某一个值。当集合为空时，key 也被删除。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228110800.png" alt="image-20220228110800704"></p>
</li>
<li><p><strong><code>srandmember &lt;key&gt; &lt;n&gt;</code></strong>：随机从 key 集合中取出 n 个值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228110920.png" alt="image-20220228110920797"></p>
</li>
<li><p><strong><code>smove &lt;source&gt; &lt;destionation&gt; &lt;value&gt;</code></strong> ：把 source 集合中的一个值移动到 destionation 集合中。destionation 集合不存在时，将创建新的集合。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228111126.png" alt="image-20220228111126311"></p>
</li>
<li><p><strong><code>sinter &lt;key1&gt; &lt;key2&gt;</code></strong>：取 key1 和 key2 集合的交集。</p>
</li>
<li><p><strong><code>sunion &lt;key1&gt; &lt;key2&gt;</code></strong>：取 key1 和 key2 集合的并集。</p>
</li>
<li><p><strong><code>sdiff &lt;key1&gt; &lt;key2&gt;</code></strong>：取 key1 - key2 集合的差集。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228111922.png" alt="image-20220228111922849"></p>
</li>
</ul>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><strong>特点：</strong></p>
<ul>
<li>哈希表的值为一个或多个键值对，这里用field代表键，field类型为String。<br>类似于Java 中的： <code>Map&lt;String, &lt;String,Object&gt;&gt;</code>。</li>
</ul>
<p><strong>数据结构：</strong></p>
<ul>
<li>当field-value长度较短且个数较少时，使用压缩列表（Zip List）。</li>
<li>否则，使用哈希表。</li>
</ul>
<h3 id="常用指令-3"><a href="#常用指令-3" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>hset &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></strong>：给哈希表 key 中 field 键赋值为 value。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/image-20220228113832778.png" alt="image-20220228113832778"></p>
</li>
<li><p><strong><code>hget &lt;key&gt; &lt;field&gt;</code></strong>：从哈希表 key 中获取 field 键的值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228115536.png" alt="image-20220228113842852"></p>
</li>
</ul>
<ul>
<li><p><strong><code>hmset &lt;key&gt; &lt;field1&gt; &lt;value1&gt; &lt;field2&gt; &lt;value2&gt;...</code></strong>：给哈希表 key 中的一个或多个 field 键设置值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228113923.png" alt="image-20220228113923180"></p>
</li>
<li><p><strong><code>hkeys &lt;key&gt;</code></strong>：列出哈希表 key 中的所有 field。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114021.png" alt="image-20220228114021722"></p>
</li>
<li><p><strong><code>hvals &lt;key&gt;</code></strong>：列出哈希表 key 中的所有 value。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114036.png" alt="image-20220228114036180"></p>
</li>
<li><p><strong><code>hexists &lt;key&gt; &lt;field&gt;</code></strong>：查看哈希表 key 中，给定的 field 键是否存在。0 不存在，1 存在。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114107.png" alt="image-20220228114107267"></p>
</li>
<li><p><strong><code>hincrby &lt;key&gt; &lt;field&gt; &lt;increment&gt;</code></strong>：为哈希表 key 中的 field 映射的值加上增量。（整数）</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114212.png" alt="image-20220228114212206"></p>
</li>
</ul>
<ul>
<li><p><strong><code>hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></strong>：将哈希表 key 中的 field 的值设置为 value，当且仅当 filed 不存在时。 </p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114644.png" alt="image-20220228114644678"></p>
</li>
<li><p><strong><code>hdel &lt;key&gt; &lt;field1&gt; [field2]</code></strong>：删除一个或多个哈希表 key 中的 filed 字段。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114704.png" alt="image-20220228114704322"></p>
</li>
<li><p><strong><code>hgetall &lt;key&gt;</code></strong>：获取在哈希表中指定 key 的所有字段和值。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228114825.png" alt="image-20220228114825196"></p>
</li>
<li><p><strong><code>hlen &lt;key&gt;</code></strong>：获取哈希表中字段的数量。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228115014.png" alt="image-20220228115014342"></p>
</li>
</ul>
<h2 id="Zset（有序集合）"><a href="#Zset（有序集合）" class="headerlink" title="Zset（有序集合）"></a>Zset（有序集合）</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p><strong>特点：</strong></p>
<ul>
<li>自动去重</li>
<li>元素有序</li>
<li>每个成员都关联了一个<strong>评分（score）</strong>，这个评分（score）被用来按照从低分到高分的方式排序集合中的成员。</li>
<li><strong>集合的成员是唯一的，但是评分可以是重复的</strong>。 </li>
</ul>
<p><strong>数据结构：</strong></p>
<h3 id="常用指令-4"><a href="#常用指令-4" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>zadd &lt;key&gt; score1 member1 [score2 member2]</code></strong>：向有序集合添加一个或多个成员，或者更新已存在成员的分数。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228121354.png" alt="image-20220228121354050"></p>
</li>
<li><p><strong><code>zrange key begin end [withscores]</code></strong>：获取 key 集合 [begin, end] 区间内的成员，withscores 显示评分。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228121415.png" alt="image-20220228121415567"></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228121426.png" alt="image-20220228121426238"></p>
</li>
<li><p><strong><code>zrangebyscore key min max [withscores] [limit]</code></strong>：返回有序集合 key 中 [min,max] 分数区间的成员列表。有序集成员按分数值递增(从小到大)次序排列。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228121845.png" alt="image-20220228121845822"></p>
<p>-inf：负无穷，+inf： 正无穷。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228121940.png" alt="image-20220228121940691"></p>
</li>
<li><p><strong><code>zrevrangebyscore key max min [withscores] [limit]</code></strong>：返回有序集 key 中 [max, min] 分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。（除了排列顺序，其它都与 zrangebyscore 相同）</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228122249.png" alt="image-20220228122249028"></p>
</li>
</ul>
<ul>
<li><p><strong><code>zincrby key increment member</code></strong>：对有序集合 key 中指定成员的分数加上增量 increment。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228123251.png" alt="image-20220228123251046"></p>
</li>
<li><p><strong><code>zcount key min max</code></strong>：计算在有序集合 key 中 [min, max] 区间分数的成员数。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228123505.png" alt="image-20220228123505008"></p>
</li>
<li><p><strong><code>zrank key memeber</code></strong>：返回有序集合 key 中指定成员的排名。（<strong>从小到达</strong>）</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228123643.png" alt="image-20220228123643331"></p>
</li>
<li><p><strong><code>zrevrank key member</code></strong>：返回有序集合 key 中指定成员的排名。（<strong>从大到小</strong>）</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228123800.png" alt="image-20220228123759908"></p>
</li>
<li><p><strong><code>zscore key member</code></strong>：返回有序集合 key 中指定成员的评分。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228123848.png" alt="image-20220228123848174"></p>
</li>
<li><p><strong><code>zrem key memebr</code></strong>：删除有序集合 key 中的指定成员。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220228123950.png" alt="image-20220228123950617"></p>
</li>
</ul>
<h1 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h1><h2 id="什么是发布和订阅"><a href="#什么是发布和订阅" class="headerlink" title="什么是发布和订阅"></a>什么是发布和订阅</h2><ul>
<li><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p>
</li>
<li><p>Redis 客户端可以订阅任意数量的频道。</p>
</li>
</ul>
<h2 id="Redis的发布和订阅-1"><a href="#Redis的发布和订阅-1" class="headerlink" title="Redis的发布和订阅"></a>Redis的发布和订阅</h2><ul>
<li><p>客户端可以订阅频道如下图</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242312206.png" alt="image-20220301095120286"></p>
</li>
<li><p>当给这个频道发布消息后，消息就会发送给订阅的客户端 </p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242312438.png" alt="image-20220301095213133"> </p>
</li>
</ul>
<h2 id="发布订阅指令实现"><a href="#发布订阅指令实现" class="headerlink" title="发布订阅指令实现"></a>发布订阅指令实现</h2><ul>
<li><p>打开一个客户端订阅 channel1</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subscribe channel1</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242312719.jpeg" alt="img"> </p>
</li>
<li><p>打开另一个客户端，给channel1发布消息hello</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publish channel1 hello</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242312802.jpeg" alt="img"></p>
<p>​                                              返回的1是订阅者数量</p>
</li>
<li><p>打开第一个客户端可以看到发送的消息</p>
</li>
<li><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242313798.jpeg" alt="img"> </li>
</ul>
<p><strong>注意</strong>：发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息。</p>
<h1 id="Redis-新数据类型"><a href="#Redis-新数据类型" class="headerlink" title="Redis 新数据类型"></a>Redis 新数据类型</h1><h2 id="Bitmpas"><a href="#Bitmpas" class="headerlink" title="Bitmpas"></a>Bitmpas</h2><h3 id="简介-5"><a href="#简介-5" class="headerlink" title="简介"></a>简介</h3><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242313930.png" alt="image-20220301100027207"></p>
<p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p>
<p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p>
<ul>
<li><p>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p>
</li>
<li><p>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242313210.png" alt="image-20220301100058491"></p>
</li>
</ul>
<h3 id="常用指令-5"><a href="#常用指令-5" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>setbit key offset value</code></strong>：设置 Bitmaps 中某个偏移量的值（0 / 1），offset 从 0 开始，</p>
<p>注意：</p>
<ul>
<li><p>0 代表最高位，如：假设 bitmaps 长度为 8，则 0 代表第 8 位。而 7 代表最低位。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit k1 0 1    # 表示设置第 0 位（最高位）为 1</span><br><span class="line">127.0.0.1:6379&gt; get k1</span><br><span class="line">&quot;\x80&quot; # 0x80 -&gt; 1000 0000</span><br><span class="line">127.0.0.1:6379&gt; setbit k2 1 1   # 表示设置第1位为 1 （左-&gt;右）</span><br><span class="line">127.0.0.1:6379&gt; get k2</span><br><span class="line">&quot;@&quot;  # @ -&gt; 64(ascii) -&gt; 0100 0000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 以此类推</span></span><br><span class="line">127.0.0.1:6379&gt; setbit k3 8 1  # 表示设置第 8 位为 1</span><br><span class="line">127.0.0.1:6379&gt; get k3</span><br><span class="line">&quot;\x00\x80&quot;  # 0x0080 -&gt; 00000000 10000000 </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; setbit k4 9 1 # 表示设置第 9 位为 0</span><br><span class="line">127.0.0.1:6379&gt; get k4 </span><br><span class="line">&quot;\x00@&quot;  #  0x0040 -&gt; 00000000 01000000</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>  示例：</p>
<p>  设置没给独立用户是否访问过网站，用Bitmaps纪录，将访问过的用户记为1，未访问过的用户记为0。假设有20个用户，userid=1，6，11，15，19的用户对网站进行了访问，那么当前 bitmaps 初始化如图：</p>
<p>  <img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242313676.png" alt="image-20220301100730913"></p>
<p>  指令如下：</p>
  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit unique:users:20220301 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20220301 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20220301 11 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20220301 15 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20220301 19 1</span><br><span class="line">(integer) 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">setbit unique:<span class="built_in">users</span>:20220303 x 1 表示独立用户x 在 20220303 这一天访问过网站。</span> </span><br></pre></td></tr></table></figure>
<p>  <strong>注：</strong></p>
<p>  很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p>
<p>  在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p>
<ul>
<li><p><strong><code>gitbit key offset</code></strong>：获取 Bitmaps 中某个偏移量的值。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit unique:users:20220301 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit unique:users:20220301 0</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>bitcount key begin end</code></strong>：统计[begin, end] 范围内的二进制位中 1 的个数。</p>
<p><strong>注意：</strong></p>
<ul>
<li>[begin,end] 区间以Byte为单位。</li>
<li>可以使用负数值：-1 表示倒数第一个字节组，-2表示倒数第二个字节组，以此类推。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">举例：当前 unique:<span class="built_in">users</span>:20220301 位图的状态如下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">00001000 01000001 00010001</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计 [0, 1] 字节组中 1 的个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount unique:users:20220301 0 1</span><br><span class="line">(integer) 4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计 [0, 2] 字节组中 1 的个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount unique:users:20220301 0 2</span><br><span class="line">(integer) 5</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计 [0, 0] 字节组中 1 的个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount unique:users:20220301 0 0</span><br><span class="line">(integer) 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计从第 1 个字节组到 倒数第 1 个字节组中 1 的个数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount unique:users:20220301 0 -1</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>BITOP 位运算 destkey srckey1 srckey2 ... srckeyN</code></strong>：对 srckey[1…N] 进行位运算（and, or, xor, not）结果存放在 destkey 中。</p>
<p>例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src1 = 01010101</span></span><br><span class="line">127.0.0.1:6379&gt; setbit src1 1 1  # 1 表示第 1 位（从左至右）</span><br><span class="line">127.0.0.1:6379&gt; setbit src1 3 1</span><br><span class="line">127.0.0.1:6379&gt; setbit src1 5 1</span><br><span class="line">127.0.0.1:6379&gt; setbit src1 7 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src2 = 10101010</span></span><br><span class="line">127.0.0.1:6379&gt; setbit src2 0 1   # 0 表示第 0 位（最高位，从左至右）</span><br><span class="line">127.0.0.1:6379&gt; setbit src2 2 1</span><br><span class="line">127.0.0.1:6379&gt; setbit src2 4 1</span><br><span class="line">127.0.0.1:6379&gt; setbit src2 6 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong><code>src1 &amp; src2</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitop and dest src1 src2 </span><br><span class="line">(integer) 1   # 执行成功</span><br><span class="line">127.0.0.1:6379&gt; get dest</span><br><span class="line">&quot;\x00&quot;  # 表示 0x00 -&gt; 0000 0000 (2进制)</span><br><span class="line">127.0.0.1:6379&gt; bitcount dest 0 0</span><br><span class="line">(integer) 0 # [0, 0] 字节组中 1 的个数为 0</span><br></pre></td></tr></table></figure>
<p><strong><code>src1 | src2</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitop or dest src1 src2</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get dest</span><br><span class="line">&quot;\xff&quot; # 0xff -&gt; 1111 1111</span><br><span class="line">127.0.0.1:6379&gt; bitcount dest 0 0</span><br><span class="line">(integer) 8</span><br></pre></td></tr></table></figure>
<p><strong><code>src1 ^ src2</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitop xor dest src1 src2 </span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get dest</span><br><span class="line">&quot;\xff&quot; # 0xff -&gt; 1111</span><br><span class="line">127.0.0.1:6379&gt; bitcount dest 0 0</span><br><span class="line">(integer) 8</span><br></pre></td></tr></table></figure>
<p><strong>~src1</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src1 的字符、ascii 和 二进制表示</span></span><br><span class="line">127.0.0.1:6379&gt; get src1</span><br><span class="line">&quot;U&quot;  # U -&gt; 85(ascii) -&gt; 0101 0101</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">按位取反</span></span><br><span class="line">127.0.0.1:6379&gt; bitop not src1 src1</span><br><span class="line">(integer) 1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">再次查看</span></span><br><span class="line">127.0.0.1:6379&gt; get src1</span><br><span class="line">&quot;\xaa&quot; # 0xaa -&gt; 1010 1010 </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h2><h3 id="简介-6"><a href="#简介-6" class="headerlink" title="简介"></a>简介</h3><p>在工作当中，我们经常会遇到与<strong>统计相关的功能需求</strong>，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。</p>
<p>但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种<strong>求集合中不重复元素个数</strong>的问题称为<strong>基数问题</strong>。</p>
<p>解决基数问题有很多种方案：</p>
<p>（1）数据存储在MySQL表中，使用<strong>distinct count计算不重复个数</strong></p>
<p>（2）使用Redis提供的<strong>hash、set、bitmaps等数据结构来处理</strong></p>
<p>以上的方案结果精确，但随着数据不断增加，<strong>导致占用空间越来越大</strong>，对于非常大的数据集是不切实际的。</p>
<p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p>
<p>Redis HyperLogLog 是用来做基数统计的算法，<strong>HyperLogLog</strong> 的<strong>优点</strong>是，<strong>在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的</strong>。</p>
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<p>什么是基数?</p>
<p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
<h3 id="常用指令-6"><a href="#常用指令-6" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>pfadd key element1 [element1]</code></strong>：  添加一个或多个指定元素到 HyperLogLog 中。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; pfadd k1 java c++ mysql redis python php</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不会添加重复元素</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd k1 java</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>pfcount key1 [key2]</code></strong>：计算 HyperLogLog 的近似基数，可以同时统计多个 HLL 的基数（不计算重复）。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  k1 = java c++ mysql redis python php</span></span><br><span class="line">127.0.0.1:6379&gt; pfcount k1</span><br><span class="line">(<span class="built_in">integer</span>) 6  </span><br><span class="line"></span><br><span class="line"><span class="comment"># k2 = java c++ rust spring tomcat </span></span><br><span class="line">127.0.0.1:6379&gt; pfcount k1 k2</span><br><span class="line">(<span class="built_in">integer</span>) 9   <span class="comment"># 去重了 java 和 c++</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>pfmerge destkey sourcekey1 [sourcekey2]</code></strong>：将一个或多个HLL合并后的结果存储在另一个HLL中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; pfmerge k3 k1 k2  </span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; pfcount <span class="title function_">k3</span></span><br><span class="line"><span class="params">(integer)</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h2><h3 id="简介-7"><a href="#简介-7" class="headerlink" title="简介"></a>简介</h3><ul>
<li>Redis 3.2 中增加了对GEO类型的支持。</li>
<li>GEO，Geographic，地理信息的缩写。</li>
<li>该类型就是元素的2维坐标，在地图上就是经纬度。</li>
<li>redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</li>
<li>有效经度从-180到180度。</li>
<li>有效纬度从 -85.05112878 到 85.05112878 度。</li>
</ul>
<p><strong>注意：</strong>没有 <strong>GEODEL</strong> 命令，因为您可以使用 ZREM 来删除元素。地理索引结构只是一个有序集合。</p>
<h3 id="常用指令-7"><a href="#常用指令-7" class="headerlink" title="常用指令"></a>常用指令</h3><ul>
<li><p><strong><code>geoadd key longitude latitude location1 [longitude latitude location2]</code></strong>：将指定的地理空间位置（纬度、经度、名称）添加到指定的<code>key</code>中。</p>
<p>longitude：n. 经度，经线</p>
<p>latitude：n. 纬度；纬度地区</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加 重庆，深圳，北京的地理信息到 china(key) 中。</span></span><br><span class="line">127.0.0.1:6379&gt; geoadd china 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>geopos  key location1 [location2]</code></strong>：获取指定地区的坐标值。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取北京的坐标值</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china beijing</span><br><span class="line">1) 1) <span class="string">&quot;116.38000041246414185&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="comment"># 获取重庆和深圳的坐标值</span></span><br><span class="line">127.0.0.1:6379&gt; geopos china chongqing shenzhen</span><br><span class="line">1) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;114.04999762773513794&quot;</span></span><br><span class="line">   2) <span class="string">&quot;22.5200000879503861&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>geodist key location1  location2  [m|km|ft|mi ]</code></strong>：获取两个地区的直线距离。</p>
<p>单位：</p>
<ul>
<li><p>m 表示单位为米[默认值]。</p>
</li>
<li><p>km 表示单位为千米。</p>
</li>
<li><p>mi 表示单位为英里。</p>
</li>
<li><p>ft 表示单位为英尺。</p>
</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 北京 -&gt; 深圳的直线距离</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china beijing shenzhen km</span><br><span class="line"><span class="string">&quot;1945.5740&quot;</span></span><br><span class="line"><span class="comment"># 获取 北京 -&gt; 重启的直线距离</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china beijing chongqing km</span><br><span class="line"><span class="string">&quot;1462.9505&quot;</span></span><br><span class="line"><span class="comment"># 获取 深圳 -&gt; 重启的直线距离</span></span><br><span class="line">127.0.0.1:6379&gt; geodist china shenzhen chongqing km</span><br><span class="line"><span class="string">&quot;1084.4275&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>georadius key longitude latitude radis [m|km|ft|mi]</code> []</strong>： 以给定的经纬度为中心，找出某一半径内的地理信息。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取 经纬度：110,30 半径 1000km 内的城市</span></span><br><span class="line">127.0.0.1:6379&gt; georadius china 110 30 1000 km</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;shenzhen&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242313797.png" alt="image-20220301122623471"></p>
</li>
</ul>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>用来</p>
<p>Jedis是 Redis的 Java 版本的客户端实现。</p>
<h2 id="Jedis-连接与注意事项"><a href="#Jedis-连接与注意事项" class="headerlink" title="Jedis 连接与注意事项"></a>Jedis 连接与注意事项</h2><h3 id="Jedis-连接"><a href="#Jedis-连接" class="headerlink" title="Jedis 连接"></a>Jedis 连接</h3><ul>
<li><p>创建 Maven 工程，引入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建测试连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">testConnection</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Jedis 对象, 完成对Jedis服务器的连接 Jedis(RedisIp, Port)</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;121.41.85.109&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 设置连接密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">    <span class="comment">// 返回值 PONG 表示连接成功</span></span><br><span class="line">    System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><p>如果连接的是远程服务器中的Redis服务，开启服务器中Redis的端口。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220301133211.png" alt="image-20220301133211690"></p>
</li>
<li><p>如果启用了防火墙，需要对防火墙开发 Redis 端口号的访问权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw status # 查看防火墙状态</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Status: inactive <span class="comment"># 未开启防火墙</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Status: active <span class="comment"># 以开启防火强</span></span></span><br><span class="line"></span><br><span class="line">sudo ufw enable # 开启防火墙</span><br><span class="line">sudo ufw disnable # 关闭防火墙</span><br><span class="line"></span><br><span class="line">sudo ufx allow port # 开启某个端口</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Jedis-API"><a href="#Jedis-API" class="headerlink" title="Jedis API"></a>Jedis API</h2><p>Jedis 中所有的 API 都和 Redis 中的指令相同，用法也大同小异，具体 API 使用可以参考 Redis 指令使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 Jedis 对象</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;121.41.85.109&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keys(*) --&gt; keys *</span></span><br><span class="line">    Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">    keys.forEach(key -&gt; System.out.print(key + <span class="string">&quot;,&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="comment">// [destnot,china,k1,k2,bitmap,src1,k3,k4,src2,dest,topN,]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// exists(key) --&gt; exists key</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> jedis.exists(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;exists = &quot;</span> + exists);   <span class="comment">// exists = true</span></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// type(key)  --&gt; type key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> jedis.type(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;type = &quot;</span> + type);  <span class="comment">// type = string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// del(key)  --&gt; del key    1 删除成功，0 删除失败。</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> jedis.del(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);    <span class="comment">// ret = 1 删除成功</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// unlink(key) --&gt; unlink key,  异步删除</span></span><br><span class="line">    ret = jedis.unlink(<span class="string">&quot;k2&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);    <span class="comment">// ret = 1 删除成功</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// expire(key, seconds) ---&gt; expire key seconds</span></span><br><span class="line">    ret = jedis.expire(<span class="string">&quot;k3&quot;</span>, <span class="number">20</span>);	<span class="comment">//  ret = 1 设置成功</span></span><br><span class="line">    System.out.println(ret);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  ttl(key) --&gt; ttl key     -2：过期，-1：永不过期，&gt; 0 剩余过期时间</span></span><br><span class="line">    ret = jedis.ttl(<span class="string">&quot;k3&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;ret = &quot;</span> + ret);    <span class="comment">// ret = 20 剩余时间20s</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;121.41.85.109&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set(String key, String value)  --&gt; set key value</span></span><br><span class="line">    jedis.set(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;abcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get(String key) --&gt; get key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">v1</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;k1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;v1 = &quot;</span> + v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mset(String ... key-value)  --&gt;  mset key value [key value]</span></span><br><span class="line">    jedis.mset(<span class="string">&quot;k2&quot;</span>, <span class="string">&quot;abcde&quot;</span>, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;12345&quot;</span>, <span class="string">&quot;k4&quot;</span>, <span class="string">&quot;efffss&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mget(String ... keys)</span></span><br><span class="line">    List&lt;String&gt; values = jedis.mget(<span class="string">&quot;k1&quot;</span>, <span class="string">&quot;k2&quot;</span>, <span class="string">&quot;k3&quot;</span>, <span class="string">&quot;k4&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;values = &quot;</span> + values);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// .... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;121.41.85.109&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    jedis.auth(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lpush(key, String...values) --&gt; lpush key value1 [value2]</span></span><br><span class="line">    jedis.lpush(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lrange(key, start, stop)  --&gt; lrange key start top</span></span><br><span class="line">    List&lt;String&gt; values = jedis.lrange(<span class="string">&quot;key1&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;values = &quot;</span> + values);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h1><ul>
<li><p><code>spring-data-redis</code> 提供的操作 Redis 的模板类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(RedisOperations.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(RedisProperties.class)</span></span><br><span class="line"><span class="meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisAutoConfiguration</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 操作：key = object, value = object</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">   <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">   <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">      RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">      template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">      <span class="keyword">return</span> template;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 操作：key = string, value = string</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">   <span class="meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span></span><br><span class="line">   <span class="keyword">public</span> StringRedisTemplate <span class="title function_">stringRedisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(redisConnectionFactory);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>线程安全。</p>
</li>
<li><p>写入和读取对象默认使用 jdk 的序列化器。</p>
</li>
</ul>
<p>操作对象</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Interface</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><em>Key Type Operations</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>GeoOperations</code></td>
<td style="text-align:left">Redis geospatial operations, such as <code>GEOADD</code>, <code>GEORADIUS</code>,…</td>
</tr>
<tr>
<td style="text-align:left"><code>HashOperations</code></td>
<td style="text-align:left">Redis hash operations</td>
</tr>
<tr>
<td style="text-align:left"><code>HyperLogLogOperations</code></td>
<td style="text-align:left">Redis HyperLogLog operations, such as <code>PFADD</code>, <code>PFCOUNT</code>,…</td>
</tr>
<tr>
<td style="text-align:left"><code>ListOperations</code></td>
<td style="text-align:left">Redis list operations</td>
</tr>
<tr>
<td style="text-align:left"><code>SetOperations</code></td>
<td style="text-align:left">Redis set operations</td>
</tr>
<tr>
<td style="text-align:left"><code>ValueOperations</code></td>
<td style="text-align:left">Redis string (or value) operations</td>
</tr>
<tr>
<td style="text-align:left"><code>ZSetOperations</code></td>
<td style="text-align:left">Redis zset (or sorted set) operations</td>
</tr>
<tr>
<td style="text-align:left"><em>Key Bound Operations</em></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><code>BoundGeoOperations</code></td>
<td style="text-align:left">Redis key bound geospatial operations</td>
</tr>
<tr>
<td style="text-align:left"><code>BoundHashOperations</code></td>
<td style="text-align:left">Redis hash key bound operations</td>
</tr>
<tr>
<td style="text-align:left"><code>BoundKeyOperations</code></td>
<td style="text-align:left">Redis key bound operations</td>
</tr>
<tr>
<td style="text-align:left"><code>BoundListOperations</code></td>
<td style="text-align:left">Redis list key bound operations</td>
</tr>
<tr>
<td style="text-align:left"><code>BoundSetOperations</code></td>
<td style="text-align:left">Redis set key bound operations</td>
</tr>
<tr>
<td style="text-align:left"><code>BoundValueOperations</code></td>
<td style="text-align:left">Redis string (or value) key bound operations</td>
</tr>
<tr>
<td style="text-align:left"><code>BoundZSetOperations</code></td>
<td style="text-align:left">Redis zset (or sorted set) key bound operations</td>
</tr>
</tbody>
</table>
</div>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul>
<li><p>导入依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="默认序列化器"><a href="#默认序列化器" class="headerlink" title="默认序列化器"></a>默认序列化器</h3><p>RedisTemplate 可以设置 4 种序列化器：</p>
<ul>
<li>keySerializer</li>
<li>valueSerializer</li>
<li>hashKeySerializer</li>
<li>hashValueSerializer</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242309960.png" alt="image-20220302230515958"></p>
<p><strong>RedisTemplate  默认使用 JDK 的序列化器：JDK序列化器</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242309435.png" alt="image-20220302224712005"></p>
<p><strong>JDK 序列化器底层使用 ObjectOutputStream 将对象转成二进制数据：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242309077.png" alt="image-20220302230643175"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate&lt;Object,Object&gt; redisTemplate;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看数据库</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;\xac\xed\x00\x05t\x00\x04name&quot;</span>    <span class="comment">//   key 添加进数据库后，前面多了一堆二进制数据</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get \xac\xed\x00\x05t\x00\x04name</span><br><span class="line">(nil)		<span class="comment">// value 直接添加失败</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="自定义序列化器"><a href="#自定义序列化器" class="headerlink" title="自定义序列化器"></a>自定义序列化器</h3><p>一般 key 都是 String 类型，而 Value 可以是任意类型。所以通过自定义序列化器到容器中（自动配置的将失效）来修改默认的序列化器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory redisConnectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 RedisTemplate</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// key 采用 String 序列化</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value 采用 Json 序列化</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看数据库（序列化成功）</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; keys *</span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;name&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get name</span><br><span class="line"><span class="string">&quot;\&quot;zhangsan\&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>一般实体类（bean）都需要实现 Serializable 接口。</strong></p>
<h2 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h2><p>使用 Json 序列化器对对象进行序列化时，会将类的全限定名写入到 Redis 中，<strong>浪费空间</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedis</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisTemplate&lt;String,Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// Value 为 User 对象</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>,<span class="string">&quot;male&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Redis 中插入的数据</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get user</span><br><span class="line"><span class="string">&quot;&#123;\&quot;@class\&quot;:\&quot;com.study.springboot.bean.User\&quot;,\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;gender\&quot;:\&quot;male\&quot;&#125;&quot;</span></span><br><span class="line"><span class="comment">// 多了一个 @class : com.study.springboot.bean.User 的键值对</span></span><br><span class="line"><span class="comment">// 通过这个键值对可以自动反序列化为User对象，但是也非常占用空间。</span></span><br></pre></td></tr></table></figure>
<p>解决方式：Value 统一使用 String 类型，RedisAutoConfiguration 提供了 StringRedisTemplate 来处理 <String,String> 类型的数据。我们手动的将对象序列化 Json 字符串，然后手动的进行反序列化即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestRedis</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> objectMapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user&quot;</span>, userString);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString1</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> objectMapper.readValue(userString1, User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;user1 = &quot;</span> + user1);  <span class="comment">// user1 = User(name=zhangsan, gender=male)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis 中插入的数据</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; get user</span><br><span class="line"><span class="string">&quot;&#123;\&quot;name\&quot;:\&quot;zhangsan\&quot;,\&quot;gender\&quot;:\&quot;male\&quot;&#125;&quot;</span>   <span class="comment">// 没有 class 键值对</span></span><br></pre></td></tr></table></figure>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h1><h2 id="Redis-事务定义"><a href="#Redis-事务定义" class="headerlink" title="Redis 事务定义"></a>Redis 事务定义</h2><p>Redis事务是一个单独的隔离操作：事务中的所有命令都会<strong>序列化</strong>、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
<p>Redis事务的主要作用就是<strong>串联多个命令</strong>防止别的命令插队。</p>
<h2 id="Redis-事务指令"><a href="#Redis-事务指令" class="headerlink" title="Redis 事务指令"></a>Redis 事务指令</h2><p>Redis 处理事务的3个命令：</p>
<ul>
<li><strong>Multi</strong>：输入Multi后，输入的指令都会依次进入<strong>命令队列</strong>中，但不会执行，类似于开启事务。</li>
<li><strong>Exec</strong>：输入Exec后，Redis会将<strong>命令队列</strong>中的命令依次执行。</li>
<li><strong>discard</strong>：组队的过程中可以通过discard来放弃组队。</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305600.png" alt="image-20220302094406107"></p>
<p><strong>代码演示：</strong></p>
<ul>
<li><p>Multi -&gt; Exec</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi     # 开启事务队列</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set k1 v1	# 指令加入事务队列中</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; exec	# 依次执行事务队列中的指令</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; keys *   # 确认执行成功</span><br><span class="line">1) &quot;k1&quot;</span><br><span class="line">2) &quot;k2&quot;</span><br><span class="line">3) &quot;k3&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Multi -&gt; Discard</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi  	# 开启事务队列</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; set a1 b1	# 指令加入事务队列中</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set a2 b2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; set a3 b3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379&gt; discard		# 放弃组队</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *	# 确认未执行事务队列中的指令</span><br><span class="line">(empty list or set)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Redis-事务的错误处理"><a href="#Redis-事务的错误处理" class="headerlink" title="Redis 事务的错误处理"></a>Redis 事务的错误处理</h2><ul>
<li><p>当组队阶段出现错误，事务队列中的所有指令都会执行失败。<br><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305091.png" alt="image-20220302100150087"></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">  127.0.0.1:6379&gt; multi     <span class="comment"># 开启事务队列</span></span><br><span class="line">  OK</span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1	<span class="comment"># 指令入队</span></span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">set</span> k2 	<span class="comment"># 指令出错</span></span><br><span class="line">  (error) ERR wrong number of arguments <span class="keyword">for</span> <span class="string">&#x27;set&#x27;</span> <span class="built_in">command</span></span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">set</span> k3 v3  <span class="comment"># 指令入队</span></span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">exec</span>	<span class="comment"># 执行事务队列执行报错，事务队列被 discard</span></span><br><span class="line">  (error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">  127.0.0.1:6379&gt; keys *  <span class="comment"># 确认队列指令执行失败</span></span><br><span class="line">  (empty list or <span class="built_in">set</span>)</span><br><span class="line"></span><br><span class="line">- 当执行阶段出现错误，只有出错的指令执行失败，其它指令会执行成功。</span><br><span class="line"></span><br><span class="line">  ~~~sh</span><br><span class="line">  127.0.0.1:6379&gt; multi     <span class="comment"># 开启事务队列</span></span><br><span class="line">  OK</span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">set</span> k1 v1	<span class="comment"># 指令入队</span></span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379&gt; incr k1	<span class="comment"># 指令入队，错误指令</span></span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">set</span> k2 v2	<span class="comment"># 指令入队</span></span><br><span class="line">  QUEUED</span><br><span class="line">  127.0.0.1:6379&gt; <span class="built_in">exec</span>	<span class="comment"># 执行事务队列</span></span><br><span class="line">  1) OK	<span class="comment"># 执行成功</span></span><br><span class="line">  2) (error) ERR value is not an <span class="built_in">integer</span> or out of range	<span class="comment"># 执行失败</span></span><br><span class="line">  3) OK	<span class="comment"># 执行成功</span></span><br><span class="line">  127.0.0.1:6379&gt; keys *	<span class="comment"># 确认队列指令 2 是否执行失败</span></span><br><span class="line">  1) <span class="string">&quot;k1&quot;</span></span><br><span class="line">  2) <span class="string">&quot;k2&quot;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Redis-事务冲突解决（锁）"><a href="#Redis-事务冲突解决（锁）" class="headerlink" title="Redis 事务冲突解决（锁）"></a>Redis 事务冲突解决（锁）</h2><p>总金额 10000 元，3 个请求并发访问：</p>
<ul>
<li><p>一个请求想给金额减 8000 元；</p>
</li>
<li><p>一个请求想给金额减 5000 元；</p>
</li>
<li><p>一个请求想给金额减 1000 元；</p>
</li>
</ul>
<p>最终可能导致事务冲突，结果如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305493.png" alt="image-20220302102252355"></p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p><strong>悲观锁(Pessimistic Lock)</strong>，顾名思义，就是很悲观。每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。<strong>传统的关系型数据库里边就用到了很多这种锁机制</strong>，比如<strong>行锁</strong>、<strong>表锁</strong>、<strong>读锁</strong>、<strong>写锁</strong>等，都是在做操作之前先上锁。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305230.png" alt="image-20220302102520115"></p>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p><strong>乐观锁(Optimistic Lock)</strong>，顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号</strong>等机制。<strong>乐观锁适用于多读的应用类型，这样可以提高吞吐量</strong>。Redis就是利用这种<strong>check-and-set</strong>机制实现事务的。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305438.png" alt="image-20220302102647545"></p>
<p>Redis 解决事务冲突通过<strong>乐观锁机制</strong>。</p>
<h2 id="Redis-乐观锁指令"><a href="#Redis-乐观锁指令" class="headerlink" title="Redis 乐观锁指令"></a>Redis 乐观锁指令</h2><ul>
<li><p><strong><code>watch key1 [key2]</code></strong>：在执行<strong>multi</strong>之前，先执行<code>watch key1 [key2]</code>, 可以监视一个(或多个) key ，如果在<strong>事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305134.png" alt="image-20220302103813673"></p>
</li>
<li><p><strong><code>unwatch</code></strong>：取消 WATCH 命令对所有 key 的监视。如果在执行 WATCH 命令之后，<strong>EXEC 命令或 DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了</strong>。</p>
</li>
</ul>
<h2 id="Redis-事务三特性"><a href="#Redis-事务三特性" class="headerlink" title="Redis 事务三特性"></a>Redis 事务三特性</h2><ul>
<li><p><strong>单独的隔离操作</strong> </p>
<p>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。 </p>
</li>
<li><p><strong>没有隔离级别的概念</strong> </p>
<p>队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行。</p>
</li>
<li><p><strong>不保证原子性</strong> </p>
<p>事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚。</p>
</li>
</ul>
<h2 id="Redis-事务秒杀案例"><a href="#Redis-事务秒杀案例" class="headerlink" title="Redis 事务秒杀案例"></a>Redis 事务秒杀案例</h2><h3 id="处理秒杀请求模拟"><a href="#处理秒杀请求模拟" class="headerlink" title="处理秒杀请求模拟"></a>处理秒杀请求模拟</h3><ul>
<li><p>秒杀商品库存设置为 10</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242305319.png" alt="image-20220302205425151"></p>
</li>
<li><p>处理秒杀请求的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeckillController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/seckill&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">seckill</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@RequestParam(value = &quot;pid&quot;, required = false)</span> Integer pid)</span> &#123;</span><br><span class="line"></span><br><span class="line">        ValueOperations&lt;String, String&gt; opsForSkStock = redisTemplate.opsForValue();</span><br><span class="line">        SetOperations&lt;String, String&gt; opsForSkList = redisTemplate.opsForSet();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 pid 是否为 null</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="literal">null</span>)<span class="keyword">return</span> <span class="string">&quot;不存在的商品 ~!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成随机的 uid</span></span><br><span class="line">        <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">        <span class="type">String</span> <span class="variable">uid</span> <span class="operator">=</span> uuid.toString().substring(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前商品的秒杀库存是否为 null</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">skStockKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span> + pid + <span class="string">&quot;:stock&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">countStr</span> <span class="operator">=</span> opsForSkStock.get(skStockKey);</span><br><span class="line">        <span class="keyword">if</span> (countStr == <span class="literal">null</span>)  <span class="keyword">return</span> <span class="string">&quot;秒杀活动暂未开启~！&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前用户是否已经在当前商品的秒杀清单中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">skListKey</span> <span class="operator">=</span> <span class="string">&quot;seckill:&quot;</span> + pid + <span class="string">&quot;:list&quot;</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">exist</span> <span class="operator">=</span> opsForSkList.isMember(skListKey, uid);</span><br><span class="line">        <span class="keyword">if</span> (exist)  <span class="keyword">return</span> <span class="string">&quot;您已经参加过秒杀活动~！&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断当前商品库存是否充足</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> Integer.parseInt(countStr);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;秒杀结束~！&quot;</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 开始秒杀</span></span><br><span class="line">        <span class="comment">// 商品库存数量 - 1</span></span><br><span class="line">        opsForSkStock.decrement(skStockKey);</span><br><span class="line">        <span class="comment">// 用户加入当前商品的秒杀清单中</span></span><br><span class="line">        opsForSkList.add(skListKey, uid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;秒杀成功~！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="AB-测试工具模拟并发"><a href="#AB-测试工具模拟并发" class="headerlink" title="AB 测试工具模拟并发"></a>AB 测试工具模拟并发</h3><ul>
<li><p>CentOS 安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure>
</li>
<li><p>Ubuntu 安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install apache2-utils</span><br></pre></td></tr></table></figure>
</li>
<li><p>工具说明</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ab --help   # 查看帮助</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Usage: ab [options] [http[s]://]hostname[:port]/path</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Options are:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -n requests     设置请求次数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -c concurrency  设置同一时间的并发数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -t timelimit    	Seconds to max. to spend on benchmarking</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                   			This implies -n 50000</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -s <span class="built_in">timeout</span>      	Seconds to max. <span class="built_in">wait</span> <span class="keyword">for</span> each response</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                   			Default is 30 seconds</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -b windowsize   	Size of TCP send/receive buffer, <span class="keyword">in</span> bytes</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -B address     	 Address to <span class="built_in">bind</span> to when making outgoing connections</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -p postfile   		    设置 POST 请求的数据，记住要设置 -T 选项</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -u putfile    	 		 设置 PUT 请求的数据，记住要设置 -T x</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -T content-type 	用于 POST/PUT 请求时，设置 Content-<span class="built_in">type</span>，</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">								  例如： -T <span class="string">&#x27;&#x27;</span>application/x-www-form-urlencoded<span class="string">&#x27;, 默认是  &#x27;</span>text/plain<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -v verbosity    How much troubleshooting info to print</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -w              Print out results in HTML tables</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -i              Use HEAD instead of GET</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -x attributes   String to insert as table attributes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -y attributes   String to insert as tr attributes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -z attributes   String to insert as td or th attributes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -C attribute    Add cookie, eg. &#x27;</span>Apache=1234<span class="string">&#x27;. (repeatable)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -H attribute    Add Arbitrary header line, eg. &#x27;</span>Accept-Encoding: gzip<span class="string">&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">                   Inserted after all normal header lines. (repeatable)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -A attribute    Add Basic WWW Authentication, the attributes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">                   are a colon separated username and password.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -P attribute    Add Basic Proxy Authentication, the attributes</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">                   are a colon separated username and password.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -X proxy:port   Proxyserver and port number to use</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -V              Print version number and exit</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -k              Use HTTP KeepAlive feature</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -d              Do not show percentiles served table.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -S              Do not show confidence estimators and warnings.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -q              Do not show progress when doing more than 150 requests</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -l              Accept variable document length (use this for dynamic pages)</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -g filename     Output collected data to gnuplot format file.</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -e filename     Output CSV file with percentages served</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="string">   -r              Don&#x27;</span>t <span class="built_in">exit</span> on socket receive errors.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -m method       Method name</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -h              Display usage information (this message)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -I              Disable TLS Server Name Indication (SNI) extension</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -Z ciphersuite  Specify SSL/TLS cipher suite (See openssl ciphers)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -f protocol     Specify SSL/TLS protocol</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                   (SSL2, TLS1, TLS1.1, TLS1.2 or ALL)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">   -E certfile     Specify optional client certificate chain and private</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>测试指令</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ab -n 1000 -c 100 -p ./postfile -T application/x-www-form-urlencoded http://192.168.43.176:8080/seckill</span><br><span class="line"><span class="comment"># -n 1000 ：1000 个请求</span></span><br><span class="line"><span class="comment"># -c 100：100 个并发</span></span><br><span class="line"><span class="comment"># -p ./postfile：当前文件夹下的 postfile 中的内容作为post请求数据</span></span><br><span class="line"><span class="comment"># -T application/x-www-form-urlencoded：POST 请求的 content-type</span></span><br><span class="line"><span class="comment">#  http://192.168.43.176:8080/seckill：请求地址（服务器ip）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># postfile 文件中的内容</span></span><br><span class="line">pid=1001&amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试产生的问题</p>
<ul>
<li><p>超卖问题：库存已经没有了，还在售卖商品。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242306451.png" alt="image-20220302205733755"></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242306742.png" alt="image-20220302205758210"></p>
</li>
<li><p>超时问题：大量请求连接耗费时间，导致超时。</p>
</li>
</ul>
</li>
</ul>
<h3 id="解决并发产生的问题"><a href="#解决并发产生的问题" class="headerlink" title="解决并发产生的问题"></a>解决并发产生的问题</h3><h4 id="解决超卖问题"><a href="#解决超卖问题" class="headerlink" title="解决超卖问题"></a>解决超卖问题</h4><h4 id="解决超时问题"><a href="#解决超时问题" class="headerlink" title="解决超时问题"></a>解决超时问题</h4><p>使用连接池，节省每次连接redis服务带来的消耗，把连接好的实例反复利用。</p>
<p>springboot 中开启连接池</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">121.41</span><span class="number">.85</span><span class="number">.109</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">lmc033088</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span>   <span class="comment"># 默认数据库索引</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">1800000</span> <span class="comment"># 连接超时时间（ms）</span></span><br><span class="line">    <span class="attr">client-type:</span> <span class="string">lettuce</span></span><br><span class="line">    <span class="comment"># 或者 url = redis://password@host:port</span></span><br><span class="line">    <span class="comment"># url: redis://lmc033088@121.41.85.109:6379</span></span><br><span class="line">    <span class="attr">lettuce:</span>   <span class="comment"># 使用 lettuce 客户端的配置</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>    <span class="comment"># 连接池最大连接式（负数表示没限制），默认值 8</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span>     <span class="comment"># 最大阻塞等待时间(负数表示没限制)</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>     <span class="comment"># 连接池中的最大空闲连接，默认值 8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>     <span class="comment"># 连接池中的最小空闲连接，默认值 0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><h2 id="短信登录-–-Redis-的共享-Session-应用"><a href="#短信登录-–-Redis-的共享-Session-应用" class="headerlink" title="短信登录 – Redis 的共享 Session 应用"></a>短信登录 – Redis 的共享 Session 应用</h2><h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242309254.png" alt="image-20220304090826928"></p>
<ul>
<li>hm-dianping：后端代码</li>
<li>nginx-1.18.0：前端代码</li>
<li>hmdp.sql：建表语句</li>
</ul>
<p>其中的表有： </p>
<ul>
<li>tb_user：用户表 </li>
<li>tb_user_info：用户详情表 </li>
<li>tb_shop：商户信息表</li>
<li>tb_shop_type：商户类型表 </li>
<li>tb_blog：用户日记表（达人探店日记） </li>
<li>tb_follow：用户关注表 </li>
<li>tb_voucher：优惠券表 </li>
<li>tb_voucher_order：优惠券的订单表</li>
</ul>
<h4 id="导入后端项目"><a href="#导入后端项目" class="headerlink" title="导入后端项目"></a>导入后端项目</h4><p>在资料中提供了一个项目源码：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220304090600.png" alt="image-20220304090600753"></p>
<p>将其复制到你的idea工作空间，然后利用idea打开即可：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/20220304090639.png" alt="image-20220304090639093"></p>
<p><strong>修改配置文件：</strong></p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">hmdp</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8081   </span></span><br><span class="line"><span class="comment"># 数据库</span></span><br><span class="line"><span class="comment">## Mysql</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://121.41.85.109:3306/heimadb?useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">1234</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## Redis</span></span><br><span class="line"><span class="attr">spring.redis.host</span>=<span class="string">121.41.85.109</span></span><br><span class="line"><span class="attr">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">spring.redis.password</span>=<span class="string">lmc033088</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-active</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.max-idle</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.min-idle</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">spring.redis.lettuce.pool.time-between-eviction-runs</span>=<span class="string">10s</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># JSON处理时忽略非空字段</span></span><br><span class="line"><span class="attr">spring.jackson.default-property-inclusion</span>=<span class="string">non_null</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Mybatis Plus</span></span><br><span class="line"><span class="comment">## 别名扫描包</span></span><br><span class="line"><span class="attr">mybatis-plus.type-aliases-package</span>=<span class="string">com.hmdp.entity</span></span><br><span class="line"><span class="comment">## 下划线 -&gt; 驼峰</span></span><br><span class="line"><span class="attr">mybatis-plus.configuration.map-underscore-to-camel-case</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># Log</span></span><br><span class="line"><span class="attr">logging.level.com.hmdp</span>: <span class="string">debug</span></span><br></pre></td></tr></table></figure>
<p>启动项目后，在浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8081/shop-type/list">http://localhost:8081/shop-type/list</a> ，如果可以看到数据则证明运行没有问题。</p>
<h4 id="导入前端项目"><a href="#导入前端项目" class="headerlink" title="导入前端项目"></a>导入前端项目</h4><p>在资料中提供了一个nginx文件夹：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242310400.png" alt="image-20220304090849424"></p>
<p>将其复制到任意目录，要确保该目录不包含中文、特殊字符和空格，例如：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242311256.png" alt="image-20220304090915215"></p>
<p>在nginx所在目录下打开一个CMD窗口，输入命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start nginx.exe</span><br></pre></td></tr></table></figure>
<p>打开chrome浏览器，在空白页面点击鼠标右键，选择检查，即可打开开发者工具，然后打开手机模式：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242311919.png" alt="image-20220304091032180"></p>
<p>然后访问: <a target="_blank" rel="noopener" href="http://127.0.0.1:8080">http://127.0.0.1:8080</a> ，即可看到页面：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242311274.png" alt="image-20220304091108197"></p>
<h3 id="基于Session实现登录"><a href="#基于Session实现登录" class="headerlink" title="基于Session实现登录"></a>基于Session实现登录</h3><p><strong>功能流程图</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242311204.png" alt="image-20220304091159843"></p>
<h4 id="发送验证码"><a href="#发送验证码" class="headerlink" title="发送验证码"></a>发送验证码</h4><p><strong>前端流程：</strong></p>
<p>登录网页 –&gt; 点击我的 –&gt; 输入手机号 –&gt; 发送验证码（method=POST, url=/user/code，requestParam=phoneNum）–&gt; 后端接收</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242311076.png" alt="image-20220304091342821"></p>
<p><strong>后端流程：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242311072.png" alt="image-20220304092018681"></p>
<p><strong>代码实现：（后端）</strong></p>
<ul>
<li><p>/user/code 控制器方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserInfoService userInfoService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送手机验证码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;code&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(<span class="meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 发送短信验证码并保存验证码</span></span><br><span class="line">        <span class="keyword">return</span> userService.sendCode(phone, session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>service</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt; <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">sendCode</span><span class="params">(String phone, HttpSession session)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 验证手机号</span></span><br><span class="line">        <span class="keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;</span><br><span class="line">            <span class="comment">// 2. 无效则返回错误信息</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(SystemConstants.MSG_INVALID_PHONE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 有效则生成验证码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomUtil.randomString(<span class="number">6</span>);  <span class="comment">// RandomUtil: hutool 下的工具类</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 验证码保存到 Redis 中</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> LOGIN_CODE_PREFIX + phone;</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.MINUTES); <span class="comment">// 设置过期时间 1m</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 发送验证码（此处w模拟）</span></span><br><span class="line">        log.debug(<span class="string">&quot;验证码发送成功: &#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="comment">// 6. 返回正确信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(code);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>​    </p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h2><p><strong>缓存</strong>就是数据交换的缓冲区（称作Cache [ kæʃ ] ），是存贮数据的临时地方，一般读写性能较高。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242216606.png" alt="image-20220424221640541"></p>
<p><strong>缓存的作用：</strong></p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p><strong>缓存的成本：</strong></p>
<ul>
<li><p>数据一致性成本</p>
</li>
<li><p>代码维护成本</p>
</li>
<li><p>运维成本</p>
</li>
</ul>
<h2 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h2><p>在不加缓存的业务中，请求会直接抵达数据库，数据库查询指定数据并返回：    </p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242219043.png" alt="image-20220424221957968"></p>
<p>在客户端和数据直接添加一层缓存，当如果请求命中了缓存，则直接返回缓存中的数据，如果没命中，再查询数据库中的数据，并且查询完毕后，应该将数据保存到缓存中，以便下次请求可以直接从缓冲中读取数据。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242222412.png" alt="image-20220424222220340"></p>
<p><strong>代码：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242223231.png" alt="image-20220424222311163"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_PREFIX + id;</span><br><span class="line"><span class="type">String</span> <span class="variable">shopCache</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"><span class="keyword">if</span> (StrUtil.isNotBlank(shopCache)) &#123;</span><br><span class="line">    <span class="comment">// 命中则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok(JSONUtil.toBean(shopCache, Shop.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未命中则在数据库中查询</span></span><br><span class="line"><span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="built_in">this</span>.baseMapper.selectById(id);</span><br><span class="line"><span class="comment">// 判断数据库中是否存在</span></span><br><span class="line"><span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123; </span><br><span class="line">    <span class="comment">// 数据库中不存在，则返回错误信息或空（具体看业务逻辑）</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;指定商品信息不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据先保存至缓存中</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop));</span><br><span class="line"><span class="comment">// 在返回</span></span><br><span class="line"><span class="keyword">return</span> Result.ok(shop);</span><br></pre></td></tr></table></figure>
<h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><p>当数据库纪录被更新之后，缓存中的数据和数据库中的数据产生了不一致性，为了消除不一致性，有以下几种策略：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242233727.png" alt="image-20220424223341644"></p>
<p>业务场景：</p>
<ul>
<li><p>低一致性需求：使用内存淘汰机制。例如店铺类型的查询缓存</p>
</li>
<li><p>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如店铺详情查询的缓存</p>
</li>
</ul>
<p>内存淘汰策略无需我们自定义，而超时剔除策略只需要添加一个过期时间，因此主要解释主动更新策略。</p>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><p>常见的主动更新策略有以下三种：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242237694.png" alt="image-20220424223734602"></p>
<p>操作缓存和数据库时有三个问题需要考虑：</p>
<ol>
<li><p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都更新缓存，无效写操作较多。</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存。</li>
</ul>
</li>
<li><p>如何保证缓存与数据库的操作的同时成功或失败？</p>
<ul>
<li>单体系统，将缓存与数据库操作放在一个事务</li>
<li>分布式系统，利用TCC等分布式事务方案</li>
</ul>
</li>
<li><p>先操作缓存还是先操作数据库？</p>
<ul>
<li><p>先删除缓存，再更新数据库，容易出现线程安全问题：</p>
<blockquote>
<p>假设旧值为 10，要更新的值为 20，此时线程 1 进行更新操作，在删除缓存后，要对数据库进行更新操作，因为更新数据库的时间相较于查询数据库时间更长，此时假设线程 2 也来查询缓存，因为缓存已经删除，所以缓存未命中，则去数据库中查询，并且在线程 1 更新完毕之前，从数据库中查询到了旧数据 10 ，更新到缓存中，并返回，那么线程 2 返回的就是旧数据 10 。而当线程 1 更新完毕后，此时数据库的值为 20，而缓存中的值为 10，就出现了数据不一致的问题。</p>
</blockquote>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242248205.png" alt="image-20220424224858125"></p>
</li>
<li><p>先操作数据库，再删除缓存，相比来说出现线程安全的几率更小。</p>
<blockquote>
<p>假设线程 2 先更新数据库，在更新的过程中缓存未被删除，其它的线程依然能命中缓存，虽然拿到的是旧数据，但等线程 2 更新数据库后，会删除缓存。之后的请求未命中缓存就会去数据库查询最新的数据，并更新缓存，保证了缓存和数据库的一致性。</p>
<p>出现缓存和数据库不一致的情况，只有在某些极端情况下，比如：假设线程 1 先来查询数据库，未命中缓存，因此去从数据库中获取到了数据，并且因为某些原因导致线程阻塞，而在线程 1 阻塞的过程中，线程 2 来更新数据库，更新完毕后删除了新的缓存，此时线程 1 阻塞结束，将旧数据更新到缓存中。</p>
<p>不过这种线程不安全的情况出现的几率相对于第一种方式来说较小，因为删除缓存的耗时要远远低于操作数据库与磁盘IO的时间。</p>
</blockquote>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242259398.png" alt="image-20220424225914307"></p>
</li>
</ul>
</li>
</ol>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新商店信息, 一旦更新成功, 立即删除 Redis 中的缓存信息。</span></span><br><span class="line"><span class="comment"> * 将更新数据库和删除Redis缓存放在一个事务中进行，保证数据的一致性。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shop 要更新的上的信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 更新失败，返回错误。更新成功，返回商店的 id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 添加事务</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateShop</span><span class="params">(Shop shop)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新数据库</span></span><br><span class="line">    <span class="keyword">if</span> (!updateById(shop)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 删除缓存</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">id</span> <span class="operator">=</span> shop.getId();</span><br><span class="line">    stringRedisTemplate.delete(CACHE_SHOP_PREFIX + id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Result.ok(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，这些请求都会被打到数据库中，验证导致数据库宕机。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241501395.png" alt="image-20220424150113315"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h4><p>数据库中未命中的请求，将空值进行缓存，下次再以相同的 key 请求时，缓存就可以被命中，从而减少了数据库的压力。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241506368.png" alt=""></p>
<ul>
<li>优点：<ul>
<li>实现简单，维护方便</li>
</ul>
</li>
<li>缺点：<ul>
<li>额外内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
<ul>
<li>代码</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241529829.png" alt="image-20220424152947713"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询店铺信息，并解决缓存穿透问题。</span></span><br><span class="line"><span class="comment">    * 缓存穿透问题: 查询缓存和数据库中都不存在的信息，则每一次查询都会去数据库中进行查询，当发送大规模恶意查询时，数据库可</span></span><br><span class="line"><span class="comment">    * 能会崩溃。</span></span><br><span class="line"><span class="comment">    * 解决方法:</span></span><br><span class="line"><span class="comment">    * 1. 缓存空值, 当查询的店铺信息不存在与缓存和数据库中时, 设置 &quot;&quot; 空字符串到缓存中, 下次再次查询这个店铺信息时, 缓存中</span></span><br><span class="line"><span class="comment">    * 已经保存了 &quot;&quot; 字符串, 就可以直接拦截这些查询请求。(本方法采用)</span></span><br><span class="line"><span class="comment">    * 2. 布隆过滤器</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id 要查询的店铺id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回查询到的店铺信息，未查询到返回 null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> Shop <span class="title function_">queryShopByIdForPassThrough</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">       <span class="comment">// 查询 Redis 是否有店铺信息的缓存</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_PREFIX + id;</span><br><span class="line"></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopCache</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断缓存中是否存在店铺信息（非 &quot;&quot; 字符串）</span></span><br><span class="line">       <span class="keyword">if</span> (StrUtil.isNotBlank(shopCache)) &#123;  </span><br><span class="line">           <span class="comment">// 存在, 直接返回店铺信息</span></span><br><span class="line">           <span class="keyword">return</span> JSONUtil.toBean(shopCache, Shop.class);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果 shopCache != null,  表示缓存中存放的是空字符串 &quot;&quot;, 那么数据库中也没有店铺信息，此处应该拦截</span></span><br><span class="line">       <span class="keyword">if</span> (shopCache != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 返回 null, 防止缓存穿透</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果 shopCache == null, 表示缓存中不存在店铺信息, 并且还未在数据库中查询过, 则在数据库中查询店铺信息</span></span><br><span class="line">       <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 判断数据库中是否存在店铺信息</span></span><br><span class="line">       <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 数据库中不存在店铺信息, 将 &quot;&quot; 字符串存入 Redis 缓存中, 设置过期时间, 并返回 null 防止缓存穿透</span></span><br><span class="line">           stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 数据库中存在店铺信息，将店铺信息转为Json字符串放入 Redis 缓存, 设置过期时间</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">shopJsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">       stringRedisTemplate.opsForValue().set(key, shopJsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 返回 shop</span></span><br><span class="line">       <span class="keyword">return</span> shop;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>缓存之上再加一层布隆过滤器，请求先到达布隆过滤器，只有布隆过滤器认为存在的请求才会放行，不存在的请求直接拒绝。</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/348332384">什么是布隆过滤器</a></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241509519.png" alt="image-20220424150957448"></p>
<ul>
<li>优点：<ul>
<li>内存占用较少，没有多余的key</li>
</ul>
</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>缓存穿透产生的原因是什么？</strong></p>
<ul>
<li>用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力</li>
</ul>
<p><strong>缓存穿透的解决方案有哪些？</strong></p>
<ul>
<li>缓存null值</li>
<li><p>布隆过滤</p>
</li>
<li><p>主动防御：</p>
<ul>
<li><p>增强id的复杂度，避免被猜测id规律</p>
</li>
<li><p>做好数据的基础格式校验</p>
</li>
<li><p>加强用户权限校验</p>
</li>
<li><p>做好热点参数的限流</p>
</li>
</ul>
</li>
</ul>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p><strong>缓存雪崩</strong>是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241538217.png" alt="image-20220424153831126"></p>
<h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul>
<li><p>给不同的Key的TTL添加随机值（解决key失效，无代码演示，实现简单）</p>
</li>
<li><p>利用Redis集群提高服务的可用性（解决redis宕机，见 redis 高级篇）</p>
</li>
<li><p>给缓存业务添加降级限流策略（见 springcloud 高级篇）</p>
</li>
<li><p>给业务添加多级缓存（见 springcloud 高级篇）</p>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><strong>缓存击穿问题</strong>也叫热点Key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p>
<ul>
<li><p>高并发访问：某些热点业务，在同一时间段内高并发访问的被访问，如秒杀等。</p>
</li>
<li><p>缓存重建业务较复杂：即某些业务可以涉及多张表，表之间的关系也比较复杂，可能需要一系列操作后才能得到结果，这个过程可能是非常耗时的，而在这段时间内，热点Key的缓存全部会未命中，如下图：</p>
</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241554052.png" alt="image-20220424155418953"></p>
<h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>使用互斥锁，只有拿到锁的线程才可以查询数据来重建缓存数据，例如：</p>
<p>线程 1 查询缓存未命中后，尝试获取互斥锁并且成功，接着查询数据库重建缓存数据。在线程 1 重建缓存数据的这段时间内，其它线程查询缓存未命中，但是获取互斥锁都失败了，则线程休眠一段时间后继续查询缓存，如果未命中，则继续尝试获取互斥锁，一直循环，直到线程 1 重建缓存数据成功并释放锁，此时其它线程就可以命中缓存并返回。如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241604306.png" alt="image-20220424160436230"></p>
<p><strong>代码：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241637791.png" alt="image-20220424163712708"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询店铺信息，解决缓存穿透，并使用互斥锁缓存击穿问题</span></span><br><span class="line"><span class="comment"> * 缓存击穿问题: 缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访</span></span><br><span class="line"><span class="comment"> * 问会在瞬间给数据库带来巨大的冲击。（见 PPT）</span></span><br><span class="line"><span class="comment"> * 解决方式一: 互斥锁</span></span><br><span class="line"><span class="comment"> * 只允许拿到互斥锁的线程 i 来查询数据库，其它线程的查询请求只能等到线程 i 在数据库查询结束并将数据进行缓存后，才可以从</span></span><br><span class="line"><span class="comment"> * 缓存中获取数据。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 要查询的店铺 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回查询到的店铺信息，未查询到返回 null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Shop <span class="title function_">queryShopByIdWithMutex</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询 Redis 是否有店铺信息的缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_PREFIX + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopCache</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断缓存中是否存在店铺信息</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isNotBlank(shopCache)) &#123;</span><br><span class="line">        <span class="comment">// 3. 存在, 直接返回店铺信息</span></span><br><span class="line">        <span class="keyword">return</span> JSONUtil.toBean(shopCache, Shop.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果 shopCache != null, 表示缓存中存放的是空字符串 &quot;&quot;, 表示数据库中也没有店铺信息</span></span><br><span class="line">    <span class="keyword">if</span> (shopCache != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 返回 null, 防止缓存穿透</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 5. 如果 shopCache == null, 表示缓存中不存在店铺信息, 并且还未在数据库中查询过</span></span><br><span class="line">    <span class="comment">// 5.1 尝试获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_PREFIX + id;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock(lockKey);</span><br><span class="line">        <span class="comment">// 5.2 判断是否获取到互斥锁</span></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 5.3 如果未获取到, 则休眠，并继续递归尝试获取</span></span><br><span class="line">            Thread.sleep(LOCK_SLEEP_TIME);</span><br><span class="line">            <span class="keyword">return</span> queryShopByIdWithMutex(id);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.4 如果获取到互斥锁, 则到数据库中查询店铺信息</span></span><br><span class="line">        shop = getById(id);</span><br><span class="line">        <span class="comment">// 模拟查询数据库的延时（测试缓存击穿）</span></span><br><span class="line">        <span class="comment">// Thread.sleep(200);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 判断数据库中是否存在店铺信息</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 7. 数据库中不存在店铺信息, 将 &quot;&quot; 字符串存入 Redis 缓存中, 设置过期时间, 并返回 null 防止缓存穿透</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 8. 数据库中存在店铺信息，将店铺信息转为Json字符串放入 Redis 缓存, 设置过期时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">shopJsonStr</span> <span class="operator">=</span> JSONUtil.toJsonStr(shop);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(key, shopJsonStr, CACHE_SHOP_TTL, TimeUnit.MINUTES);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 9. 释放互斥锁</span></span><br><span class="line">        unlock(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. 返回 shop</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取互斥锁</span></span><br><span class="line"><span class="comment"> * 		使用 setnx key value 来充当互斥锁, setnx 只会在 key 不存在时生效, 因此在第一个线程 setnx 成功（拿到锁）之后到该线程 del lockKey（释</span></span><br><span class="line"><span class="comment"> * 放锁）之前, 任何线程对 lockey 的 setnx 操作都将返回 false。</span></span><br><span class="line"><span class="comment"> * 		设置过期时间防止持有锁的线程出现异常导致死锁。过期时间设置应该比正常缓存重建时间要长，防止缓存重建过程中锁被提前释放，从而导</span></span><br><span class="line"><span class="comment"> * 致缓存击穿现象的再次发生。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lockKey 缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> setnx 成功返回 true，当前线程等同于获取到互斥锁。 setnx 失败返回 false，互斥锁已经被其它线程获取。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">hasLock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(lockKey, LOCK_VALUE, LOCK_TTL, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">return</span> BooleanUtil.isTrue(hasLock); <span class="comment">// 使用工具类, 防止空指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">    stringRedisTemplate.delete(lockKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逻辑过期时间"><a href="#逻辑过期时间" class="headerlink" title="逻辑过期时间"></a>逻辑过期时间</h4><p>不给缓存设置过期时间 ex ，而是给缓存中添加一个逻辑过期时间字段，这意味着缓存理论上永远都不会被删除。例如：</p>
<p>当线程 1 查询缓存发现逻辑时间已经过期，则同样获取互斥锁，并且<strong>开启一个新线程来进行缓存重建</strong>，而线程 1 则直接返回过期的数据。在新线程进行缓存重建的这段时间内，其它线程查询缓存同样会发现逻辑时间已经过期，并且因为互斥锁已经被持有，因此其它线程也直接返回过期的数据。直到新县城缓存重建成功、重置逻辑过期时间、并释放锁后，其它线程在查询缓存得到的就是最新的数据。如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204241613234.png" alt="image-20220424161302139"></p>
<p><strong>代码：</strong></p>
<p>一般逻辑过期时间添加在热点key上，而热点key一般都是活动开始前提前预热到redis中，当活动结束后在将热点key删除，因此从理论上来讲在活动期间，对于热点key的请求都会命中（逻辑过期时间不会正在的删除缓存），因此对于活动接口请求如果未命中热点key，只能说明请求的key不是活动的商品，此时可以直接返回null或者一些错误信息（具体看业务逻辑）。而在命中的情况下，我们则需要判断热点key有没有逻辑过期，如果过期了我们就需要来获取互斥锁，如果获取互斥锁成功，则新开启一个线程来重建缓存。而不管获取互斥锁是否成功，我们都需要直接返回旧的数据。只有当新线程重建缓存成功后，对于热点key的请求才是最新的数据，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242114414.png" alt="image-20220424211447311"></p>
<p>因为要额外增加一个逻辑过期字段，因此可以考虑重新封装一个类，类中除了热点key映射的数据外，还额外有一个额外过期时间字段，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description: 用于封装热点key, 多了Logic过期时间属性</span></span><br><span class="line"><span class="comment"> * User: joker</span></span><br><span class="line"><span class="comment"> * Date: 2022-03-04-15:39</span></span><br><span class="line"><span class="comment"> * Time: 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisData</span> &#123;</span><br><span class="line">    <span class="comment">// 逻辑过期时间</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime logicExpireTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据本体</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缓存预热，提前将热点key的数据和逻辑过期时间添加到缓存中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从数据库中获取店铺信息,并存入 Redis 中</span></span><br><span class="line"><span class="comment">     * 用于提前将数据库中的热点数据缓存到 Redis 中，并设置逻辑过期时间（缓存预热）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id            要查询的店铺 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireSeconds 缓存过期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveShopToRedis</span><span class="params">(Long id, Long expireSeconds)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 查询店铺数据</span></span><br><span class="line">        <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 模拟查询数据库的延时（测试缓存击穿）</span></span><br><span class="line">        <span class="comment">// Thread.sleep(200);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 店铺数据为 null 则直接返回。</span></span><br><span class="line">        <span class="keyword">if</span> (shop == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 给shop数据添加逻辑过期时间（不会被Redis自动清理）</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(shop);</span><br><span class="line">        redisData.setLogicExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将封装后的数据写入 Redis</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(CACHE_SHOP_PREFIX + id, JSONUtil.toJsonStr(redisData));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用逻辑过期时间解决缓存击穿问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询店铺信息, 使用逻辑过期时间解决缓存击穿问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Shop <span class="title function_">queryShopByIdWithLogicExpireTime</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询 Redis 是否有店铺信息的缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> CACHE_SHOP_PREFIX + id;</span><br><span class="line">    <span class="type">String</span> <span class="variable">shopCache</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断缓存中是否存在店铺信息</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isBlank(shopCache)) &#123;</span><br><span class="line">        <span class="comment">// 3. 不存在, 直接返回 null（进行过缓存预热, 如果缓存中没有也不考虑去数据库查询）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 存在，从缓存信息中获取逻辑过期时间和商店信息</span></span><br><span class="line">    <span class="type">RedisData</span> <span class="variable">redisHotData</span> <span class="operator">=</span> JSONUtil.toBean(shopCache, RedisData.class);</span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> JSONUtil.toBean((JSONObject) redisHotData.getData(), Shop.class);</span><br><span class="line">    <span class="type">LocalDateTime</span> <span class="variable">logicExpireTime</span> <span class="operator">=</span> redisHotData.getLogicExpireTime();</span><br><span class="line">    <span class="comment">// 5. 判断缓存的逻辑过期时间是否到期</span></span><br><span class="line">    <span class="keyword">if</span> (logicExpireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 6. 未过期, 则将缓存的商店信息直接返回</span></span><br><span class="line">        <span class="keyword">return</span> shop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 7. 过期, 则尝试更新缓存</span></span><br><span class="line">    <span class="comment">// 7.1 获取互斥锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_SHOP_PREFIX + id;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">        <span class="comment">// 7.2 如果获取成功, 新开一个线程去数据库查询商店信息, 更新到缓存中</span></span><br><span class="line">        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                saveShopToRedis(id, LOGIC_EXPIRE_TIME_SHOP);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 7.3 释放锁</span></span><br><span class="line">                unlock(lockKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 8. 当前线程依然返回已过期的商店信息（不确保一致性，但效率较高）</span></span><br><span class="line">    <span class="keyword">return</span> shop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两种方案的对比"><a href="#两种方案的对比" class="headerlink" title="两种方案的对比"></a>两种方案的对比</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">互斥锁</td>
<td>没有额外的内存消耗，因为不需要额外存储非数据字段。<br>保证一致性<br>实现简单</td>
<td>线程需要等待，性能受影响<br>可能有死锁风险</td>
</tr>
<tr>
<td style="text-align:center">逻辑过期时间</td>
<td>线程无需等待，性能较好</td>
<td>不保证一致性<br>有额外内存消耗<br>实现复杂</td>
</tr>
</tbody>
</table>
</div>
<h3 id="缓存工具封装"><a href="#缓存工具封装" class="headerlink" title="缓存工具封装"></a>缓存工具封装</h3><p>基于StringRedisTemplate封装一个缓存工具类，满足下列需求：</p>
<ul>
<li><p>方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间。</p>
</li>
<li><p>方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓存击穿问题。</p>
</li>
<li><p>方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题。</p>
</li>
<li><p>方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题。</p>
</li>
</ul>
<p>工具类实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">CACHE_REBUILD_EXECUTOR</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheClient</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 data 对象以 Json 字符串的格式写入 Redis 缓存中, 并设置过期时间（TTL）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheKey 缓存的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data     缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout  key的过期时间（TTL）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit 过期时间的单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithTTL</span><span class="params">(String cacheKey, Object data, Long timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStrData</span> <span class="operator">=</span> JSONUtil.toJsonStr(data);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(cacheKey, jsonStrData, timeout, timeUnit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将 data 对象以 Json 字符串的格式写入 Redis 缓存中, 并设置逻辑过期时间（LogicExpireTime LET）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheKey        缓存的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data            缓存的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logicExpireTime key的逻辑过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit        过期时间的单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWithLET</span><span class="params">(String cacheKey, Object data, Long logicExpireTime, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置逻辑过期时间，封装为 RedisData 对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisData</span>();</span><br><span class="line">        redisData.setData(data);</span><br><span class="line">        redisData.setLogicExpireTime(LocalDateTime.now().plusSeconds(timeUnit.toSeconds(logicExpireTime)));</span><br><span class="line">        <span class="comment">// 写入 Redis 缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStrData</span> <span class="operator">=</span> JSONUtil.toJsonStr(redisData);</span><br><span class="line">        stringRedisTemplate.opsForValue().set(cacheKey, jsonStrData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询并解决缓存穿透问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cacheKeyPrefix 缓存 key 的前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id             数据的 id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type           数据类型的Class对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout        缓存的超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeUnit       超时时间的单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dbFallback     查询的函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;I&gt;            id 的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;R&gt;            数据的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> null 缓存中不存在并且数据库中也不存在。r 缓存中查询到或者数据库中查询到的数据对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;I, R&gt; R <span class="title function_">queryWithPassThrough</span><span class="params">(</span></span><br><span class="line"><span class="params">            String cacheKeyPrefix, I id, Class&lt;R&gt; type, Long timeout, TimeUnit timeUnit, Function&lt;I, R&gt; dbFallback)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> cacheKeyPrefix + id;</span><br><span class="line">        <span class="comment">// 从 Redis 中查询指定 key 的数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStrData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据是 &quot;&quot; 字符串，直接返回（解决缓存穿透问题）</span></span><br><span class="line">        <span class="keyword">if</span> (CACHE_NULL_VALUE.equals(jsonStrData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据存在</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(jsonStrData)) &#123;</span><br><span class="line">            <span class="comment">// 转换为指定类型并返回</span></span><br><span class="line">            <span class="keyword">return</span> JSONUtil.toBean(jsonStrData, type);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数据不存在，到数据库中查询</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果返回值为 null</span></span><br><span class="line">        <span class="keyword">if</span> (r == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 将 &quot;&quot; 字符串写入到缓存（解决缓存穿透问题）</span></span><br><span class="line">            stringRedisTemplate.opsForValue().set(key, CACHE_NULL_VALUE, CACHE_NULL_TTL, TimeUnit.MINUTES);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果返回值不为 null</span></span><br><span class="line">        <span class="comment">// 将数据转换为Json字符串</span></span><br><span class="line">        setWithTTL(key, r, timeout, timeUnit);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询数据并使用逻辑过期时间解决缓存击穿问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;I, R&gt; R <span class="title function_">queryWithLogicExpireTime</span><span class="params">(</span></span><br><span class="line"><span class="params">            String cacheKeyPrefix, I id, Class&lt;R&gt; type, String lockKeyPrefix, Long logicExpireTimeToSet, TimeUnit timeUnit, Function&lt;I, R&gt; dbFallback)</span> &#123;</span><br><span class="line">        <span class="comment">// 到Redis中查询缓存数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">cacheKey</span> <span class="operator">=</span> cacheKeyPrefix + id;</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonStrData</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(cacheKey);</span><br><span class="line">        <span class="comment">// 如果缓存中没有数据，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isBlank(jsonStrData)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果缓存中有数据，则将json字符串反序列化 RedisData 对象</span></span><br><span class="line">        <span class="type">RedisData</span> <span class="variable">redisData</span> <span class="operator">=</span> JSONUtil.toBean(jsonStrData, RedisData.class);</span><br><span class="line">        <span class="comment">// 获取逻辑过期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">logicExpireTime</span> <span class="operator">=</span> redisData.getLogicExpireTime();</span><br><span class="line">        <span class="comment">// 将Json对象转换为指定类型的数据</span></span><br><span class="line">        <span class="type">R</span> <span class="variable">r</span> <span class="operator">=</span> JSONUtil.toBean(((JSONObject) redisData.getData()), type);</span><br><span class="line">        <span class="comment">// 判断数据是否过期</span></span><br><span class="line">        <span class="keyword">if</span> (logicExpireTime.isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">            <span class="comment">// 如果没有过期，则直接返回数据</span></span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经过期，需要缓存重建</span></span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> lockKeyPrefix + id;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock(lockKey);</span><br><span class="line">        <span class="comment">// 如果获取成功</span></span><br><span class="line">        <span class="keyword">if</span> (isLock) &#123;</span><br><span class="line">            <span class="comment">// 开启新的线程到数据库中查询最新数据</span></span><br><span class="line">            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 查询数据库</span></span><br><span class="line">                    <span class="type">R</span> <span class="variable">data</span> <span class="operator">=</span> dbFallback.apply(id);</span><br><span class="line">                    <span class="comment">// 模拟查询数据库的延时（测试缓存击穿）</span></span><br><span class="line">                    Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    <span class="comment">// 更新到缓存中, 并设置逻辑过期时间</span></span><br><span class="line">                    <span class="built_in">this</span>.setWithLET(cacheKey, data, logicExpireTimeToSet, timeUnit);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 在新线程中释放锁</span></span><br><span class="line">                    unlock(lockKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回旧数据</span></span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(lockKey, LOCK_VALUE, LOCK_TTL, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> BooleanUtil.isTrue(isLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">        stringRedisTemplate.delete(lockKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用工具类方法的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">queryShopById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用封装的工具类来查询店铺信息</span></span><br><span class="line">    <span class="comment">// 代码四: 解决缓存穿透问题</span></span><br><span class="line">    <span class="comment">// Shop shop = cacheClient.queryWithPassThrough(CACHE_SHOP_PREFIX, id, Shop.class, CACHE_SHOP_TTL, TimeUnit.MINUTES, this::getById);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代码五: 利用逻辑过期时间解决缓存击穿问题</span></span><br><span class="line">    <span class="type">Shop</span> <span class="variable">shop</span> <span class="operator">=</span> cacheClient.queryWithLogicExpireTime(</span><br><span class="line">            CACHE_SHOP_PREFIX, id, Shop.class, LOCK_SHOP_PREFIX, LOGIC_EXPIRE_TIME_SHOP, TimeUnit.SECONDS, <span class="built_in">this</span>::getById);</span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> shop == <span class="literal">null</span> ? Result.fail(MSG_INEXISTENT_SHOP) : Result.ok(shop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优惠卷秒杀"><a href="#优惠卷秒杀" class="headerlink" title="优惠卷秒杀"></a>优惠卷秒杀</h1><h2 id="全局唯一ID"><a href="#全局唯一ID" class="headerlink" title="全局唯一ID"></a>全局唯一ID</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在商城项目中，每个店铺都可以发布优惠卷，当用户使用优惠卷来抢购商品时会生成订单并保持到数据库的优惠卷订单表中，如果这张表使用自增ID会存在以下问题：</p>
<ul>
<li>ID的规律性太明显，很容易被猜测到一些信息，比如订单号会暴露给用户，如果使用自增ID，用户今天下单，明天也下单，那么两个订单ID相减，大概能猜测出商城一天的销量，并被不怀好意的人利用。</li>
<li>受单表数据量的限制，订单随着时间的增长会越来越多，如果超过单表的限制后，新产生的订单可能需要存储在新的订单表中，那么不同表的主键自增是独立的，这就可能产生订单ID重复的问题。</li>
</ul>
<p>针对上述问题，我们可以创建一个全局ID生成器。</p>
<h3 id="全局ID生成器"><a href="#全局ID生成器" class="headerlink" title="全局ID生成器"></a>全局ID生成器</h3><p><strong>全局ID生成器</strong>是一种在分布式系统下用来生成全局唯一ID的工具，一般要满足下列特性：</p>
<ul>
<li>唯一性，生成的ID<strong>全局</strong>唯一。</li>
<li>高可用</li>
<li>高性能</li>
<li>递增性，生成的ID单调递增，方便数据库创建索引。</li>
<li>安全性，生成的ID不能是简单的顺序递增。</li>
</ul>
<h3 id="Redis-生成全局ID"><a href="#Redis-生成全局ID" class="headerlink" title="Redis 生成全局ID"></a>Redis 生成全局ID</h3><p>使用 Redis 中 String 数据结构中的 <code>incr</code> 指令来实现全局ID生成器。</p>
<p>为了增加ID的安全性，我们可以不直接使用Redis自增的数值，而是拼接一些其它信息：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251336337.png" alt="image-20220425133642282"></p>
<p><strong>ID的组成部分：</strong></p>
<ul>
<li>符号位：1bit，永远为0</li>
<li>时间戳：31bit，以秒为单位，可以使用69年</li>
<li>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * User: joker</span></span><br><span class="line"><span class="comment"> * Date: 2022-03-05-21:08</span></span><br><span class="line"><span class="comment"> * Time: 21:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200</span>; <span class="comment">// 设置为 2022-1-1 00:00:00</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SERIAL_BITS</span> <span class="operator">=</span> <span class="number">32</span>;  <span class="comment">// 序列号所占的比特位数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成全局唯一ID，类型为 long, 共 64 位：</span></span><br><span class="line"><span class="comment">     * 0 - 31：序列号，由 Redis 自增值的得到</span></span><br><span class="line"><span class="comment">     * 32 - 62：时间戳，由当前时间戳 - 开始时间戳得到</span></span><br><span class="line"><span class="comment">     * 63：符号位</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的全局唯一ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 生成 0 - 31 位序列号</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 1.1. 获取当前日期字符串，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 1.2 拼接 Redis 生成自增序列号的 key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;incr:&quot;</span> + keyPrefix + date;</span><br><span class="line">        <span class="comment">// 1.3 通过自增的方式获取序列号（如果key不存在，则自动创建key, 并且值为&quot;1&quot;）</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">serialNum</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 生成时间戳</span></span><br><span class="line">        <span class="comment">// 2.1 生成当前时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nowTimestamp</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="comment">// 2.2 当前时间戳 - 开始时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowTimestamp - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 位运算得到最终 id 并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; SERIAL_BITS | serialNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>全局唯一ID生成策略：</p>
<ul>
<li>UUID</li>
<li>Redis自增</li>
<li>snowflake算法</li>
<li>数据库自增</li>
</ul>
<p>Redis自增ID策略：</p>
<ul>
<li><p>每天一个key，方便统计订单量</p>
</li>
<li><p>ID构造是 时间戳 + 计数器</p>
</li>
</ul>
<h2 id="实现优惠卷秒杀下单"><a href="#实现优惠卷秒杀下单" class="headerlink" title="实现优惠卷秒杀下单"></a>实现优惠卷秒杀下单</h2><p>每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要秒杀抢购：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251443965.png" alt="image-20220425144321903"></p>
<p>表关系如下：</p>
<ul>
<li><p>tb_voucher：优惠券的基本信息，优惠金额、使用规则等</p>
</li>
<li><p>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</p>
</li>
</ul>
<p>在VoucherController中提供了一个接口，可以添加秒杀优惠券：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251443076.png" alt="image-20220425144343998"></p>
<p>用户可以在店铺页面中抢购这些优惠券：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251444522.png" alt="image-20220425144421448"></p>
<p>下单时需要判断两点：</p>
<ul>
<li><p>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</p>
</li>
<li><p>库存是否充足，不足则无法下单</p>
</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251444802.png" alt="image-20220425144453726"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 添加事务</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 查询秒杀优惠卷信息</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById((voucherId));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 判断秒杀优惠卷是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在的优惠卷！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 判断优惠活动是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 未开始，返回错误信息</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠活动未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4. 判断优惠活动是否结束</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 已结束，返回错误信息</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠活动已结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 5. 判断优惠卷库存是否充足</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">      <span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 6. 扣减库存</span></span><br><span class="line">      <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">              .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">              .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">              .update();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 7. 创建订单</span></span><br><span class="line">      <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">      <span class="comment">// 7.1 设置订单id，生成全局唯一ID</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line">      voucherOrder.setId(orderId);</span><br><span class="line">      <span class="comment">// 7.2 设置用户id，从当前线程中取userID（在登录拦截器中通过UserHolder保存了当前用户的ID）</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      voucherOrder.setUserId(userId);</span><br><span class="line">      <span class="comment">// 7.3 设置优惠卷id</span></span><br><span class="line">      voucherOrder.setVoucherId(voucherId);</span><br><span class="line">      <span class="comment">// 7. 写入数据库</span></span><br><span class="line">      voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 8. 返回订单ID</span></span><br><span class="line">      <span class="keyword">return</span> Result.ok(voucherId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>所谓超卖问题，即在多线程并发访问下，原本只有 n 个库存的优惠卷，实际被抢购了大于 n 个优惠卷，那么此时优惠卷的库存就会是负值，例如：当前优惠卷库存为 1 ，此时线程 1 访问，并查询数据库中的库存，发现库存大于 0 于是准备执行扣减库存的操作，而在线程 1 扣减库存完成之前，其它线程也进来访问，查询数据库中的库存，此时库存依然为 1，因此也执行扣减库存的操作，那么只有 1 个库存的优惠卷，就会被扣减2次，导致超卖问题的发生。如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251513603.png" alt="image-20220425151332504"></p>
<p>超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁，常见的锁机制：</p>
<ul>
<li><p><strong>悲观锁</strong></p>
<blockquote>
<p>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，<strong>确保线程串行执行</strong>。例如：Synchronized、Lock都属于悲观锁。</p>
<p>悲观锁因为是串行执行，因此性能不高，不适合高并发场景。</p>
</blockquote>
</li>
<li><p><strong>乐观锁</strong></p>
<blockquote>
<p>认为线程安全问题不一定会发生，因此<strong>不加锁</strong>，只是在<strong>更新数据时去判断有没有其它线程对数据做了修改</strong>。</p>
<ul>
<li><p>如果没有修改则认为是安全的，自己才更新数据。</p>
</li>
<li><p>如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。</p>
</li>
</ul>
<p>乐观锁因为被没有加锁，因此性能要高于悲观锁。</p>
</blockquote>
</li>
</ul>
<p>下面主要介绍乐观锁。</p>
<h3 id="乐观锁-1"><a href="#乐观锁-1" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的方式有两种：</p>
<ul>
<li>版本号机制</li>
<li>CAS机制</li>
</ul>
<h4 id="版本号机制"><a href="#版本号机制" class="headerlink" title="版本号机制"></a>版本号机制</h4><p>数据库中使用一个版本号字段，每次在修改操作前先查询数据库中纪录的版本号，在修改时，只有当前版本号与之前查询的版本号相同时才进行修改操作，并且在修改时要更新版本号信息，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251528665.png" alt="image-20220425152802559"></p>
<h4 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h4><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101430930">CAS机制详解</a></p>
<p>针对优惠卷秒杀业务，每次都需要查询库存信息来判断是否充足，同时更新业务时更新的就是库存信息，所以在本业务中库存和版本号的作用一样，因此直接使用库存来替代版本号即可。</p>
<p>注意：因为本业务中，库存单调递减，因此不会出现ABA问题。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251543681.png" alt="image-20220425154323578"></p>
<h3 id="乐观锁-CAS-解决超卖问题"><a href="#乐观锁-CAS-解决超卖问题" class="headerlink" title="乐观锁 CAS 解决超卖问题"></a>乐观锁 CAS 解决超卖问题</h3><p>使用乐观锁解决超卖问题时，还会存在一个缺点，即请求的成功率太低，比如：有 100 个库存，此时同样有 100 个线程并发访问，这 100 个线程都获取到库存为 100，此时线程 1 更新库存后剩余 99 个库存，那么剩下的 99 个线程拿着之前查询到的 100 库存与当前库存 99 去对比一定会失败。</p>
<p>解决的方式可以使用自旋锁机制，即当对比失败后，一直循环获取库存进行查询更新尝试，直到库存为0。</p>
<p>针对于本业务来说，可以不使用自旋锁机制，而是判断只要当前库存 &gt; 0 就允许进行更新操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span>  <span class="comment">// 添加事务</span></span><br><span class="line">  <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 查询秒杀优惠卷信息</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById((voucherId));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 判断秒杀优惠卷是否存在</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在的优惠卷！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 判断优惠活动是否开始</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 未开始，返回错误信息</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠活动未开始！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4. 判断优惠活动是否结束</span></span><br><span class="line">      <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">          <span class="comment">// 已结束，返回错误信息</span></span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠活动已结束！&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 5. 判断优惠卷库存是否充足</span></span><br><span class="line">      <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">      <span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 6. 扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">          .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)     <span class="comment">// set stock = stock - 1</span></span><br><span class="line">      	.eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)  <span class="comment">// where voucher_id = ?</span></span><br><span class="line">      	<span class="comment">// .eq(&quot;stock&quot;, stock) // and stock = &#123;stock&#125;，缺点：失败率高，即使 stock &gt; 0 当前线程的操作依然会失败</span></span><br><span class="line">      	.gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)     <span class="comment">// and stock &gt; 0  优化：只要当前纪录中 stock &gt; 0 就允许当前线程执行修改操作</span></span><br><span class="line">      .	update();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">          <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 7. 创建订单</span></span><br><span class="line">      <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">      <span class="comment">// 7.1 设置订单id，生成全局唯一ID</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line">      voucherOrder.setId(orderId);</span><br><span class="line">      <span class="comment">// 7.2 设置用户id，从当前线程中取userID（在登录拦截器中通过UserHolder保存了当前用户的ID）</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">      voucherOrder.setUserId(userId);</span><br><span class="line">      <span class="comment">// 7.3 设置优惠卷id</span></span><br><span class="line">      voucherOrder.setVoucherId(voucherId);</span><br><span class="line">      <span class="comment">// 7. 写入数据库</span></span><br><span class="line">      voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 8. 返回订单ID</span></span><br><span class="line">      <span class="keyword">return</span> Result.ok(voucherId);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h2 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>需求：修改秒杀业务，要求同一个优惠券，一个用户只能下一单。</p>
<p>需要在扣减库存之前先通过当前用户id 和 优惠卷id 来判断订单表中是否已经存在，如果存在则返回异常，如果不存在才允许扣减库存，并创建订单。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251611795.png" alt="image-20220425161136710"></p>
<p>需要注意的是，我们新增的判断订单是否存在的功能，是需要查询数据库，假设有 n 个线程并发访问，它们的用户 id 优惠卷 id 相同，同时查询数据库时，因为还没有创建该用户id和优惠卷id的订单，因此订单不会存在，那么这 n 个线程就可以继续扣减库存，创建订单，这样还是参数了多线程安全问题。</p>
<p>而解决多线程安全问题，我们可以加锁，问题是应该使用悲观锁还是乐观锁呢？</p>
<blockquote>
<p>因为，我们要先进行查询订单是否存在才决定当前线程能否进行后续操作，这不涉及到更改库存表的信息，因此我们只能使用悲观锁来解决，也就是在判断订单是否存在一直到创建订单这一系列功能代码都需要加上悲观锁。</p>
</blockquote>
<p>既然使用悲观锁，下一个问题就是我们应该用什么作为锁呢？</p>
<blockquote>
<p>如果使用this作为锁，因为spring中的组件默认都是单实例的，所有线程持有的this都是同一个对象，那么其它用户的线程也会被锁住，这显然不符合一人一单的业务逻辑。而每一个线程都持有自己的用户id，因此我们可以使用用户id作为锁来实现一人一单二业务。</p>
</blockquote>
<h3 id="使用悲观锁解决一人一单"><a href="#使用悲观锁解决一人一单" class="headerlink" title="使用悲观锁解决一人一单"></a>使用悲观锁解决一人一单</h3><p>优惠卷秒杀业务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查询秒杀优惠卷信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> seckillVoucherService.getById((voucherId));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 判断秒杀优惠卷是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在的优惠卷！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 判断优惠活动是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 未开始，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠活动未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 判断优惠活动是否结束</span></span><br><span class="line">    <span class="keyword">if</span> (seckillVoucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 已结束，返回错误信息</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;优惠活动已结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 判断优惠卷库存是否充足</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">stock</span> <span class="operator">=</span> seckillVoucher.getStock();</span><br><span class="line">    <span class="keyword">if</span> (stock &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 创建订单，并返回订单 id</span></span><br><span class="line">    <span class="keyword">return</span> createOrderWithpPessimisticLocking(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建订单的业务整体加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用悲观锁来保证一人一单</span></span><br><span class="line"><span class="comment">     * 使用乐观锁来保证超卖情况</span></span><br><span class="line"><span class="comment">     * 存在问题：只适用于单体系统，分布式系统同样存在线程安全问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="keyword">public</span> Result <span class="title function_">createOrderWithpPessimisticLocking</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">     <span class="comment">// 1. 使用 userId 作为锁(只会锁住相同用户的操作)，</span></span><br><span class="line">     <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">     <span class="comment">// toString() 底层是 new String()，因此要保证锁的唯一性，需要将字符串手动入池</span></span><br><span class="line">     <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;  <span class="comment">// 【加锁】</span></span><br><span class="line">         <span class="comment">// 2. 判断用户是否已经参加过活动</span></span><br><span class="line">         <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">         <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="comment">// 用户已经参加过活动</span></span><br><span class="line">             <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 3. 扣减库存（使用乐观锁 CAS 法来解决超卖情况）</span></span><br><span class="line">         <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().</span><br><span class="line">                 setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)     <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                 .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)  <span class="comment">// where voucher_id = ?</span></span><br><span class="line">                 <span class="comment">// .eq(&quot;stock&quot;, stock)          // and stock = ?，缺点：失败率高，即使 stock &gt; 0 当前线程的操作依然会失败</span></span><br><span class="line">                 .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)     <span class="comment">// and stock &gt; 0  优化：只要当前纪录中 stock &gt; 0 就允许当前线程执行修改操作</span></span><br><span class="line">                 .update();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">             <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 4. 创建订单</span></span><br><span class="line">         <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">         <span class="comment">// 4.1 设置订单id</span></span><br><span class="line">         <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line">         voucherOrder.setId(orderId);</span><br><span class="line">         <span class="comment">// 4.2 设置用户id</span></span><br><span class="line">         voucherOrder.setUserId(userId);</span><br><span class="line">         <span class="comment">// 4.3 设置优惠卷id</span></span><br><span class="line">         voucherOrder.setVoucherId(voucherId);</span><br><span class="line">         <span class="comment">// 5. 写入数据库</span></span><br><span class="line">         voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line">         <span class="comment">// 6. 返回订单 id</span></span><br><span class="line">         <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="一人一单的并发安全问题"><a href="#一人一单的并发安全问题" class="headerlink" title="一人一单的并发安全问题"></a>一人一单的并发安全问题</h3><p>在上面的实现中，我们使用 synchronized 悲观锁来解决一人一单问题，在单体项目下这种实现方式不会出现问题，因为同一个项目内JVM的锁监视器只有一个。而在分布式项目下，一个服务可能部署了多个实例，每个实例的JVM不同，因此锁监视器也不同，假设：线程 1 是服务实例 1 中的线程持有了用户 i 的 id，而线程 2 是服务实例 2 中的线程也持有了用户 i 的 id，当线程1 和 线程 2 同时访问时，它们获取的锁分别保存在各自JVM中锁监视器中，相互间不会影响，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251654870.png" alt="image-20220425165458747"></p>
<p>解决的方式就是使用<strong>分布式锁</strong>。</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><h2 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h2><p>在上面的一人一单问题中，我们发现使用  synchronized 作为悲观锁，无法解决分布式项目的线程安全问题，原因在上面已经分析过。如果我们将锁监视器定义为全局共享的，那么不论线程位于哪个项目，它们所使用的锁监视器都是同一个，也就能避免了分布式情况下的线程安全问题，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251704914.png" alt="image-20220425170411792"></p>
<p><strong>分布式锁：</strong>满足分布式系统或集群模式下多进程可见并且互斥的锁。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251704275.png" alt="image-20220425170457200"></p>
<h2 id="不同实现方式的对比"><a href="#不同实现方式的对比" class="headerlink" title="不同实现方式的对比"></a>不同实现方式的对比</h2><p>分布式锁的核心是<strong>实现多进程之间互斥</strong>，而满足这一点的方式有很多，常见的有三种：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251708914.png" alt="image-20220425170820833"></p>
<h2 id="Redis-实现分布式锁"><a href="#Redis-实现分布式锁" class="headerlink" title="Redis 实现分布式锁"></a>Redis 实现分布式锁</h2><h3 id="Redis实现分布式锁思路"><a href="#Redis实现分布式锁思路" class="headerlink" title="Redis实现分布式锁思路"></a>Redis实现分布式锁思路</h3><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li><p><strong>获取锁：</strong></p>
<ul>
<li><p>互斥性：确保只能有一个线程获取锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setnx lock value</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加锁过期时间，避免服务宕机引起的死锁</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire lock 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>保证以上两个命令的原子性，在极端情况下可能出现获取锁后还没来得及设置锁的过期时间，服务器发生了宕机，那么也会导致死锁，因此改用使用：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nx 时互斥 ex 是设置过期时间</span></span><br><span class="line"><span class="built_in">set</span> lock value ex 10 nx</span><br></pre></td></tr></table></figure>
</li>
<li><p>非阻塞式：尝试一次成功，返回true，失败返回false。</p>
</li>
</ul>
</li>
<li><p><strong>释放锁：</strong></p>
<ul>
<li><p>手动释放</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del lock</span><br></pre></td></tr></table></figure>
</li>
<li><p>超时释放：过期自动删除</p>
</li>
</ul>
</li>
</ul>
<p><strong>流程图：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204251733533.png" alt="image-20220425173300443"></p>
<p>在使用 Redis 实现分布式锁前，先定义分布式锁的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁持有的超时时间，过期后自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表获取锁成功; false代表获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Redis实现分布式锁版本-1"><a href="#Redis实现分布式锁版本-1" class="headerlink" title="Redis实现分布式锁版本 1"></a>Redis实现分布式锁版本 1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁 key 的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁的key = 前缀 + 业务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis模板对象 &lt;String,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 业务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleLock</span><span class="params">(String name, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> name != <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.key = KEY_PREFIX + name;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long timeoutSec)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> Thread.currentThread().getId() + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="built_in">this</span>.key, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(isLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.delete(<span class="built_in">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式锁误删问题"><a href="#分布式锁误删问题" class="headerlink" title="分布式锁误删问题"></a>分布式锁误删问题</h3><p><strong>版本 1 分布式锁存在误删问题，考虑以下情况：</strong></p>
<p>当线程 1 访问，获取分布式锁成功，但是在执行业务时因为某些原因发生了堵塞现象，导致了<strong>锁的超时释放</strong>，那么此时线程 2 访问就可以成功获取锁，并执行业务。在线程 2 执行业务的过程中，线程 1 结束了堵塞状态并且执行业务成功，那么线程 1 此时就会将锁释放掉，问题是此时的分布式锁不属于线程 1 持有，这会导致线程 1 释放了已经不属于自己的锁，并且会使得其它的线程又可以获取到锁，如此恶性循环下去，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204260910131.png" alt="image-20220426091001024"></p>
<p><strong>解决的方式：</strong></p>
<p>我们在版本 1 的实现中使用了线程id作为分布式锁的值，我们可以使用一个<strong>全局唯一的标识</strong>作为分布式锁的值，当尝试删除锁时，首先应该判断当前锁的值和我们之前设置进去的值是否相同，如果相同才允许将锁释放，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204260913904.png" alt="image-20220426091319801"></p>
<p><strong>新的实现思路如下：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204260914186.png" alt="image-20220426091401113"></p>
<h3 id="Redis实现分布式锁版本-2"><a href="#Redis实现分布式锁版本-2" class="headerlink" title="Redis实现分布式锁版本 2"></a>Redis实现分布式锁版本 2</h3><p>需求：修改之前的分布式锁实现，满足：</p>
<ol>
<li><p>在获取锁时存入线程标示（可以用UUID表示）</p>
</li>
<li><p>在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致</p>
<ul>
<li><p>如果一致则释放锁</p>
</li>
<li><p>如果不一致则不释放锁</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock1</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁 key 的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁 threadId 的前缀，使用 &quot;UUID-&quot; 来区分唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">THREAD_ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁的key = 前缀 + 业务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis模板对象 &lt;String,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 业务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock1</span><span class="params">(String name, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> name != <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.key = KEY_PREFIX + name;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 将线程唯一标识作为分布式锁的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="built_in">this</span>.key, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(isLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取分布式锁 key 映射的 value</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="built_in">this</span>.key);</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 判断标识是否一致</span></span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(lockValue)) &#123;</span><br><span class="line">            <span class="comment">// 如果一致，才释放锁</span></span><br><span class="line">            redisTemplate.delete(<span class="built_in">this</span>.key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分布式锁的原子性"><a href="#分布式锁的原子性" class="headerlink" title="分布式锁的原子性"></a>分布式锁的原子性</h3><p>分布式锁版本 2 的实现，在大部分情况下都可以解决误删问题，但是考虑一种极端情况：假设线程 1 访问，获取锁成功，并正常执行完业务，接着判断锁标识也一致，那么下一步就准备释放锁。而恰恰就在这一时刻线程 1 堵塞了（比如 JVM full gc 时所有线程堵塞），导致了线程 1 的锁被超时释放，那么此时线程 2 就可以获取到锁并执行业务，而线程 2 在执行业务的过程中，线程 1 结束了堵塞，线程 1 此时就会将线程 2 的锁给释放掉，又一次出现了误删问题，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204260951857.png" alt="image-20220426095152757"></p>
<p>出现问题的位置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="built_in">this</span>.key);</span><br><span class="line">    <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">    <span class="comment">// 判断锁标识</span></span><br><span class="line">    <span class="keyword">if</span> (threadId.equals(lockValue)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【线程发送堵塞】</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        redisTemplate.delete(<span class="built_in">this</span>.key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>产生这种情况的原因是判断锁标识和释放锁是两个操作，因此堵塞可以发生在两个操作间，而解决的方式是：<strong>保证判断锁标识和释放锁是一个原子性操作</strong>。</p>
<h3 id="Lua脚本解决多条命令原子性问题"><a href="#Lua脚本解决多条命令原子性问题" class="headerlink" title="Lua脚本解决多条命令原子性问题"></a>Lua脚本解决多条命令原子性问题</h3><p>因为Redis本身提供的事务不保证多条命令的原子性（详见第八章），因此使用Lua脚本来解决多条命令的原子性问题。</p>
<p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法大家可以参考网站：<a target="_blank" rel="noopener" href="https://www.runoob.com/lua/lua-tutorial.html">https://www.runoob.com/lua/lua-tutorial.html</a></p>
<h4 id="lua-调用redis命令"><a href="#lua-调用redis命令" class="headerlink" title="lua 调用redis命令"></a>lua 调用redis命令</h4><p>这里重点介绍Redis提供的调用函数，语法如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行redis命令</span></span><br><span class="line">redis.call(<span class="string">&#x27;命令名称&#x27;</span>, <span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;其它参数&#x27;</span>, ...)</span><br></pre></td></tr></table></figure>
<p>例如，我们要执行set name jack，则脚本是这样：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行 set name jack</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>例如，我们要先执行set name Rose，再执行get name，则脚本如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 先执行 set name jack</span></span><br><span class="line">redis.call(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line"><span class="comment">-- 再执行 get name</span></span><br><span class="line"><span class="keyword">local</span> name = redis.call(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="comment">-- 返回</span></span><br><span class="line"><span class="keyword">return</span> name</span><br></pre></td></tr></table></figure>
<h4 id="redis-调用-lua-脚本"><a href="#redis-调用-lua-脚本" class="headerlink" title="redis 调用 lua 脚本"></a>redis 调用 lua 脚本</h4><p>写好脚本以后，需要用Redis命令来调用脚本，调用脚本的常见命令如下：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261025466.png" alt="image-20220426102532390"></p>
<p>例如，我们要执行 redis.call(‘set’, ‘name’, ‘jack’) 这个脚本，语法如下：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261025378.png" alt="image-20220426102543315"></p>
<p>如果脚本中的key、value不想写死，可以作为参数传递。<strong>key类型参数会放入KEYS数组，其它参数会放入ARGV数组</strong>，在脚本中可以从KEYS和ARGV数组获取这些参数：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261027245.png" alt="image-20220426102705178"></p>
<h4 id="Lua脚本释放锁"><a href="#Lua脚本释放锁" class="headerlink" title="Lua脚本释放锁"></a>Lua脚本释放锁</h4><p><strong>释放锁的业务流程是这样的：</strong></p>
<ol>
<li><p>获取锁中的线程标示</p>
</li>
<li><p>判断是否与指定的标示（当前线程标示）一致</p>
</li>
<li><p>如果一致则释放锁（删除）</p>
</li>
<li><p>如果不一致则什么都不做</p>
</li>
</ol>
<p><strong>如果用Lua脚本来表示则是这样的：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示</span></span><br><span class="line"><span class="comment">-- 获取锁中的标示，判断是否与当前线程标示一致</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;GET&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">  <span class="comment">-- 一致，则删除锁</span></span><br><span class="line">  <span class="keyword">return</span> redis.call(<span class="string">&#x27;DEL&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，则直接返回</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="Redis实现分布式锁版本-3"><a href="#Redis实现分布式锁版本-3" class="headerlink" title="Redis实现分布式锁版本 3"></a>Redis实现分布式锁版本 3</h3><p>需求：基于Lua脚本实现分布式锁的释放锁逻辑</p>
<p>提示：RedisTemplate调用Lua脚本的API如下：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261029112.png" alt="image-20220426102937003"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock2</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁 key 的前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁 threadId 的前缀，使用 &quot;UUID-&quot; 来区分唯一标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">THREAD_ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁的 lua 脚本对象，泛型参数为脚本的返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 UNLOCK_SCRIPT</span></span><br><span class="line">        UNLOCK_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置脚本文件的位置</span></span><br><span class="line">        UNLOCK_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/unlock_simple.lua&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置脚本文件的返回值</span></span><br><span class="line">        UNLOCK_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁的key = 前缀 + 业务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * redis模板对象 &lt;String,String&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 业务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock2</span><span class="params">(String name, StringRedisTemplate redisTemplate)</span> &#123;</span><br><span class="line">        <span class="keyword">assert</span> name != <span class="literal">null</span>;</span><br><span class="line">        <span class="built_in">this</span>.key = KEY_PREFIX + name;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(Long timeoutSec)</span> &#123;</span><br><span class="line">        <span class="comment">// 将线程唯一标识作为分布式锁的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(<span class="built_in">this</span>.key, threadId, timeoutSec, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(isLock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用lua脚本来释放锁</span></span><br><span class="line"><span class="comment">     * 保证 UNLOCK_SCRIPT 文件中定义的脚本具备原子性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> THREAD_ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 执行 lua 脚本, 将 key 和 threadId 作为参数传递给脚本文件</span></span><br><span class="line">        redisTemplate.execute(UNLOCK_SCRIPT, Collections.singletonList(<span class="built_in">this</span>.key), threadId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>lua 脚本：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- unlock_simple.lua</span></span><br><span class="line"><span class="comment">-- KEYS[] 数组用于存放参数 key，下标从 1 开始</span></span><br><span class="line"><span class="comment">-- ARGV[] 数组用于存在其它参数，下标从 1 开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比较线程标识与锁中的标识是否一致</span></span><br><span class="line"><span class="keyword">if</span>(redis.call(<span class="string">&#x27;get&#x27;</span>, KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 一致，删除锁</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 不一致，返回 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><strong>基于Redis的分布式锁实现思路：</strong></p>
<ul>
<li><p>利用set nx ex获取锁，并设置过期时间，保存线程标示</p>
</li>
<li><p>释放锁时先判断线程标示是否与自己一致，一致则删除锁</p>
</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li><p>利用set nx满足互斥性</p>
</li>
<li><p>利用set ex保证故障时锁依然能释放，避免死锁，提高安全性</p>
</li>
<li><p>利用Redis集群保证高可用和高并发特性</p>
</li>
</ul>
<p><strong>存在的问题：</strong></p>
<ul>
<li><p><strong>不可重入</strong>：setnx 属于不可重入锁，同一个线程无法多次获取同一把锁。</p>
<blockquote>
<p>例如，线程 1 通过 setnx 获取锁，并执行方法 A，而方法 A 调用方法 B，在方法 B 中同样需要获取锁才能执行，此时缓存中已经有锁的信息，所以setnx 会失败，因此无法再次获取到同一把锁，那么线程 1 就会等待，而线程 1 一直等待也就不会释放锁，因此就导致死锁发生。</p>
</blockquote>
</li>
<li><p><strong>不可重试</strong>：获取锁只尝试一次就返回false，没有重试机制。</p>
</li>
<li><p><strong>超时释放</strong>：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，进而可能导致其它线程获取锁，引发线程安全问题。</p>
</li>
<li><p><strong>主从一致性</strong>：如果Redis提供了主从集群，主从同步存在延迟，当主宕机时，如果从并同步主中的锁数据，则会出现锁失效。</p>
</li>
</ul>
<p>针对上述问题，如果自己编写实现解决方案十分复杂，因此推荐使用成熟工具 <strong>Redisson</strong> 来进行解决。</p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><h3 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261104404.png" alt="image-20220426110446330"></p>
<p>官网地址： <a target="_blank" rel="noopener" href="https://redisson.org/">https://redisson.org</a></p>
<p>GitHub地址： <a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p>
<p>中文文档：<a target="_blank" rel="noopener" href="https://github.com/redisson/redisson/wiki/目录">目录 · redisson/redisson Wiki (github.com)</a></p>
<h3 id="快速入门-1"><a href="#快速入门-1" class="headerlink" title="快速入门"></a>快速入门</h3><ol>
<li>引入依赖：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>配置Redisson客户端：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://121.41.85.109:6379&quot;</span>).setPassword(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>使用Redisson的分布式锁</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"><span class="meta">@Test</span> <span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 获取锁（可重入），指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);   </span><br><span class="line">    <span class="comment">// 尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">// 判断释放获取成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 ReddssonClient 获取分布式锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span>  RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用 Redisson 客户端来获取分布式锁，并实现线程的安全</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> voucherId 优惠卷 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 秒杀订单id</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 使用 业务名称:userId 作为锁的一部分(只会锁住相同用户的操作)</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 获取 Redisson 提供的可重入锁</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + <span class="string">&quot;order:&quot;</span> + userId;</span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">    <span class="comment">// 3. 尝试加锁，参数（获取锁的最大等待时间，锁的租赁时间，时间单位）</span></span><br><span class="line">    <span class="comment">// boolean isLock = lock.tryLock(MAX_WAIT_TIME, LOCK_LEASE_TIME, TimeUnit.SECONDS);</span></span><br><span class="line">    <span class="comment">// 无参API，最大等待时间 -1（非阻塞式），获取锁失败直接返回false,  锁的租赁时间默认 30s</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">        <span class="comment">// 如果获取锁失败，则当前用户已经获取了分布式锁，返回错误信息。</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 判断用户是否已经参加过活动</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 用户已经参加过活动</span></span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 扣减库存（使用乐观锁 CAS 法来解决超卖情况）</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().</span><br><span class="line">                setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)     <span class="comment">// set stock = stock - 1</span></span><br><span class="line">                .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)  <span class="comment">// where voucher_id = ?</span></span><br><span class="line">                .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)     <span class="comment">// and stock &gt; 0  优化：只要当前纪录中 stock &gt; 0 就允许当前线程执行修改操作</span></span><br><span class="line">                .update();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 创建订单</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 5.1 设置订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 5.2 设置用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 5.3 设置优惠卷id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="comment">// 6. 写入数据库</span></span><br><span class="line">        voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 返回订单 id</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Redisson-的可重入锁原理"><a href="#Redisson-的可重入锁原理" class="headerlink" title="Redisson 的可重入锁原理"></a>Redisson 的可重入锁原理</h3><h4 id="为什么-setnx-是不可重入的？"><a href="#为什么-setnx-是不可重入的？" class="headerlink" title="为什么 setnx 是不可重入的？"></a>为什么 setnx 是不可重入的？</h4><p>例如线程 1 在方法一中首次获取锁成功：<code>setnx lock:order thread1</code>，此时 redis 中就保存了锁的信息，那么假设方法一中调用方法二，而方法二依然需要获取同一把锁才能执行业务，此时不论是线程 1 还是其它线程都无法 setnx 成功，这样就会导致死锁发生，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261156375.png" alt="image-20220426115618240"></p>
<h4 id="可重入锁原理"><a href="#可重入锁原理" class="headerlink" title="可重入锁原理"></a>可重入锁原理</h4><p>以 java 实现的 ReentrantLock 为例，其内部维护了一个 <code>state</code> 变量，初始为 0，用于纪录当前锁的重入次数。</p>
<ul>
<li><p>第一次尝试获取锁时，<code>state == 0</code>，会保存锁的信息，更新 <code>state++</code>，并且保存当前线程的信息，返回 true。</p>
</li>
<li><p>当第二次获取尝试获取锁时，<code>state == 1</code>，那么就会比较当前线程和之前保存的线程是否相同，如果相同，则直接更新 <code>state++</code>，并返回 true。</p>
</li>
<li>在释放锁时，同样判断当前线程是否是持有这把锁的线程，如果是，则更新 <code>state--</code>，如果 <code>state == 0</code>，则将线程信息置为 <code>null</code>，并返回 true 表示释放锁成功。如果 <code>state &gt; 0</code>，则返回 false，表示没有真正的释放锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();  <span class="comment">// 获取当前线程</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();  <span class="comment">// 获取锁的 state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// 如果是第一次获取</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;   <span class="comment">//  state++</span></span><br><span class="line">            setExclusiveOwnerThread(current);    <span class="comment">//   保存当前线程信息</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是第一次获取</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;  <span class="comment">// 判断当前线程和锁持有者线程是否一致</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;  <span class="comment">// 如果一致 state++</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);  <span class="comment">// 保存 state</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则返回 false，表示获取锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;  <span class="comment">// state--</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())  <span class="comment">// 如果当前线程不是锁持有者线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();  <span class="comment">// 抛异常</span></span><br><span class="line">    <span class="comment">// 如果是</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;    <span class="comment">// state == 0 时</span></span><br><span class="line">        free = <span class="literal">true</span>;  <span class="comment">// 释放锁的真值置位 true，表示释放锁</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>); <span class="comment">// 将线程信息设置为空</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);  <span class="comment">// 设置 state </span></span><br><span class="line">    <span class="keyword">return</span> free; <span class="comment">// 返回是否释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Redisson-解决不可重入"><a href="#Redisson-解决不可重入" class="headerlink" title="Redisson 解决不可重入"></a>Redisson 解决不可重入</h4><p>上面介绍到可重入锁使用 <code>线程标识</code> 来判断当前线程是否为锁的持有者，并且维护了一个 <code>state</code> 变量，来判断是否为重入获取锁。从而实现了可重入锁。而在 redis 中我们可以使用 hash 结构来保存 <code>线程标识  ：state</code> 。</p>
<p>可重入锁的获取与释放流程如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242303286.png" alt="image-20220308153819788"></p>
<p>因为要保证获取锁和释放锁的原子性，因此我们需要使用 lua 脚本来完成获取锁和释放锁的功能：</p>
<p><strong>获取可重入锁：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 使用 Redis 中的 Hash 结构来实现可重入锁</span></span><br><span class="line"><span class="comment">---     ● key 代表锁的 key</span></span><br><span class="line"><span class="comment">---     ● field 代表锁线程标识</span></span><br><span class="line"><span class="comment">---     ● value 代表锁的重入次数</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]         <span class="comment">-- 锁的 key</span></span><br><span class="line"><span class="keyword">local</span> threadId = ARGV[<span class="number">1</span>]    <span class="comment">-- 锁的线程标识</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>] <span class="comment">-- 锁的释放时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 判断指定的锁是否存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;EXISTS&#x27;</span>, key) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 2. 如果不存在：设置锁、设置线程标识、初始化锁的重入次数为 1、设置超时时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 如果存在，再判断锁是否为当前线程所持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, threadId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 4. 如果是当前线程持有锁，则锁的获取次数 + 1、重置超时时间</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, threadId, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 5. 否则，锁存在，但不是当前线程持有，返回锁的剩余释放时间</span></span><br><span class="line"><span class="keyword">return</span> redis.call(<span class="string">&#x27;ttl&#x27;</span>, KEYS[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>释放可重入锁：</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--- 使用 Redis 中的 Hash 结构来实现可重入锁</span></span><br><span class="line"><span class="comment">---     ● key 代表锁的 key</span></span><br><span class="line"><span class="comment">---     ● field 代表锁线程标识</span></span><br><span class="line"><span class="comment">---     ● value 代表锁的获取次数，初始值为 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]             <span class="comment">-- 锁的 key</span></span><br><span class="line"><span class="keyword">local</span> currentThreadId = ARGV[<span class="number">1</span>] <span class="comment">-- 当前线程的标识（不一定是当前锁的线程标识）</span></span><br><span class="line"><span class="keyword">local</span> releaseTime = ARGV[<span class="number">2</span>]     <span class="comment">-- 锁的释放时间</span></span><br><span class="line"><span class="comment">-- 判断锁是否为当前线程所持有</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, key, currentThreadId) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果不是当前线程所持有，则直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 如果是当前线程所持有，将锁的重入次数 - 1</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, currentThreadId, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 判断锁的重入次数是否为 0</span></span><br><span class="line"><span class="keyword">if</span> (count &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="comment">-- 如果大于 0，则重置锁的释放时间，并返回 0</span></span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, releaseTime)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 如果等于 0，则可以删除锁，并返回 1 </span></span><br><span class="line">redis.call(<span class="string">&#x27;HDEL&#x27;</span>, key)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="Redisson-源码分析"><a href="#Redisson-源码分析" class="headerlink" title="Redisson 源码分析"></a>Redisson 源码分析</h4><p>Redisson 实现可重入锁的逻辑和我们上面的 lua 脚本基本相同，我们跟踪源码来观察一下：</p>
<p>当我们调用 <code>RedissonClient#getLock(name)</code> 方法时，Redisson底层给我们创建了一个 RedissonLock 的对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261308637.png" alt="image-20220426130825557"></p>
<p>当我们尝试获取锁时，例如调用 <code>RedissonLock#tryLock()</code> 空参方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br></pre></td></tr></table></figure>
<p>底层经过一系列调用链，最终调用 <code>RedissonLock#tryAcquireOnceAsync()</code> </p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261631210.png" alt="image-20220426163156064"></p>
<p>可以看到，无论有没有设置释放时间，最终都会调用 <code>RedissonLock#tryLockInnerAsync</code> 方法，源码如下：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/image-20220426163057908.png" alt="image-20220426163057908"></p>
<p>当我们尝试释放锁时，最终也是通过一系列调用链执行了 lua 脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261628171.png" alt="image-20220426162856037"></p>
<h3 id="Redisson-的锁重试原理"><a href="#Redisson-的锁重试原理" class="headerlink" title="Redisson 的锁重试原理"></a>Redisson 的锁重试原理</h3><p>当我们在调用 <code>tryLock()</code> 方法时<strong>，设置了等待时间，RedissonLock 就会开启锁的重试机制</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>同样是经过一系列的调用链，但与之前调用无参 <code>tryLock()</code> 不同的是，其中增加了等待重试的代码，不过目前不是重点。</p>
<p>在这个调用链中调用了 <code>tryAcquireAsync()</code> 方法：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261436092.png" alt="image-20220426143619959"></p>
<p>该方法与空参 <code>tryLock()</code> 调用链中的 <code>tryAcquireOnceAsync()</code> 不同之处在于：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261441938.png" alt="image-20220426144144821"></p>
<p>不重试获取锁方法 <code>tryAcquireOnceAsync()</code> 返回的是 Boolean 类型，而重试获取锁方法 <code>tryAcquireAsync()</code> 返回的是 Long 类型。 这两个方法最终都调用了执行 lua 脚本的 <code>tryLockInnerAsync()</code> 方法：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261444617.png" alt="image-20220426144459519"></p>
<p>这个脚本成功返回 <code>null</code> 而失败返回剩余释放时间，那么再根据上面两个方法的不同可知：</p>
<ul>
<li>如果是不重试的获取锁方法  <code>tryAcquireOnceAsync()</code> ，它会将 Lua 脚本的返回值，转换为 Boolean 类型，并直接返回。</li>
<li>而重试的获取锁方法 <code>tryLockInnerAsync()</code> ，它会将 Lua 脚本的返回值，转为 Long 类型，而如果获取锁成功那么返回值就是 null。</li>
</ul>
<p>问题来了，这与锁重试机制有什么关系？</p>
<p>让我们再回到之前省略的那部分省略的等待重试代码：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261506043.png" alt="image-20220426150610860"></p>
<p><strong>流程图如下：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242303530.png" alt="image-20220308214300459"></p>
<h3 id="Redisson-解决超时释放原理"><a href="#Redisson-解决超时释放原理" class="headerlink" title="Redisson 解决超时释放原理"></a>Redisson 解决超时释放原理</h3><p>当我们没有设置锁的释放时间，Redisson 自动设置一个释放时间 <code>getLockWatchDogTimeout()</code>，这个值默认时 <code>30 s</code>。</p>
<p>并且，无论是重试的 <code>tryAcquireAsync()</code> 方法，还是不重试的 <code>tryAcquireOnceAsync()</code> 方法，只要 <code>leaseTime == -1</code> ，它们再调用完 lua 脚本获取锁之后都会再执行一个回调函数，这个回调函数主要做两件事情：</p>
<ol>
<li>更新锁的重入次数。</li>
<li>如果是第一次获取锁，则开启更新锁释放时间的定时任务。</li>
</ol>
<p>这个机制被称为<strong>Watch Dog</strong>：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261543557.png" alt="image-20220426154316358"></p>
<p>上面递归的执行定时任务，直到释放锁时，才会调用一个回调函数，来尝试取消定时任务：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204261548182.png" alt="image-20220426154851070"></p>
<p><code>cancelExpirationRenewal()</code> 方法，主要任务有两个：</p>
<ol>
<li>减少锁的重入次数</li>
<li>如果锁的重入次数 == 0，则</li>
</ol>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/image-20220426155353524.png" alt="image-20220426155353524"></p>
<p><strong>流程图如下：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242304340.png" alt="image-20220308230823750"></p>
<h3 id="Redisso-解决主从一致性问题"><a href="#Redisso-解决主从一致性问题" class="headerlink" title="Redisso 解决主从一致性问题"></a>Redisso 解决主从一致性问题</h3><p>前面实现的锁都是在单节点Redis的情况下。这十分依赖这唯一一台节点的可靠性，如果这个节点出现意外后整个Redis服务就会瘫痪。为了保证高可用性，一般会建立Redis分布式集群，比如：一个主节点负责写操作，多个从节点负责查询操作。为了保证主从节点的一致性，要在主从节点间做数据同步，当主节点泵机后，从节点会代替作为主节点。不过，这也会产生一些问题，因为主从同步存在延迟，如果在主节点刚刚把锁的信息还未来得及向从节点同步时发生了宕机，就会导致锁失效，从而引发线程安全问题，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242304212.png" alt="image-20220310114506797"></p>
<p>为了解决这个问题，我们可以同时部署多台主节点，每个主节点之间没有关系。当线程想获取锁时，只有3个主节点都 setnx 成功，才能获取到锁。这样就算有一个主节点宕机了并且未完成主从同步，其它线程此时想获取锁，setnx 时也只有接替宕机的新节点能成功，其它的主节点都将失败，那么其它线程获取锁也将会失败。这样就保证了锁的有效性，并且多个节点也保证了整个服务的高可用性，这种机制也被称作<strong>联锁</strong>。如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242304417.png" alt="image-20220310115554382"></p>
<h4 id="MultiLock"><a href="#MultiLock" class="headerlink" title="MultiLock"></a>MultiLock</h4><p>首先是配置多台 Redis 客户端：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204242304599.png" alt="image-20220310171546593"></p>
<p>在配置类中添加 Redis 客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试联锁的3个节点</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://121.41.85.109:7001&quot;</span>).setPassword(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://121.41.85.109:7002&quot;</span>).setPassword(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加了单点的地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://121.41.85.109:7003&quot;</span>).setPassword(<span class="string">&quot;lmc033088&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MultiLockTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient1;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RLock multiLock;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建联锁</span></span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock1</span> <span class="operator">=</span> redissonClient1.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock2</span> <span class="operator">=</span> redissonClient2.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock3</span> <span class="operator">=</span> redissonClient3.getLock(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建联锁，使用哪个 client 调用 getMultiLock 都没有区别</span></span><br><span class="line">        multiLock = redissonClient1.getMultiLock(lock1, lock2, lock3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> multiLock.tryLock(<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取联锁失败 ... 1&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取联锁成功 ... 1&quot;</span>);</span><br><span class="line">            method2();</span><br><span class="line">            log.info(<span class="string">&quot;开始执行业务 ... 1&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;执行业务完毕 ... 1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            multiLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> multiLock.tryLock(<span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;获取联锁失败 ... 2&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;获取联锁成功 ... 2&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;开始执行业务 ... 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;准备释放联锁 ... 2&quot;</span>);</span><br><span class="line">            multiLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MultiLock-源码"><a href="#MultiLock-源码" class="headerlink" title="MultiLock 源码"></a>MultiLock 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> waitTime, <span class="type">long</span> leaseTime, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">newLeaseTime</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;  <span class="comment">// 如果设置 leaseTime </span></span><br><span class="line">          <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) &#123; <span class="comment">// 如果设置了 waitTime</span></span><br><span class="line">              newLeaseTime = unit.toMillis(leaseTime);  <span class="comment">// leaseTime 不变</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              newLeaseTime = unit.toMillis(waitTime)*<span class="number">2</span>;  <span class="comment">// leaseTime 等于 waitTime * 2</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="type">long</span> <span class="variable">remainTime</span> <span class="operator">=</span> -<span class="number">1</span>;  <span class="comment">// 剩余时间</span></span><br><span class="line">      <span class="keyword">if</span> (waitTime != -<span class="number">1</span>) &#123;  <span class="comment">// 如果设置了 waitTime </span></span><br><span class="line">          remainTime = unit.toMillis(waitTime);  </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> <span class="variable">lockWaitTime</span> <span class="operator">=</span> calcLockWaitTime(remainTime);  <span class="comment">// lockWaitTime 也等于 remainTime（方法里直接 return remainTime）</span></span><br><span class="line">      </span><br><span class="line">      <span class="type">int</span> <span class="variable">failedLocksLimit</span> <span class="operator">=</span> failedLocksLimit();  <span class="comment">// 获取锁失败的限制数，默认值为 0（不允许失败）</span></span><br><span class="line">      List&lt;RLock&gt; acquiredLocks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(locks.size());  <span class="comment">// 保存获取成功的锁</span></span><br><span class="line">      <span class="keyword">for</span> (ListIterator&lt;RLock&gt; iterator = locks.listIterator(); iterator.hasNext();) &#123;  <span class="comment">// 遍历保存的所有锁</span></span><br><span class="line">          <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> iterator.next();  </span><br><span class="line">          <span class="type">boolean</span> lockAcquired;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (waitTime == -<span class="number">1</span> &amp;&amp; leaseTime == -<span class="number">1</span>) &#123;  <span class="comment">// 如果 waitTime 和 leaseTime 都没有设置</span></span><br><span class="line">                  lockAcquired = lock.tryLock(); <span class="comment">// 则获取锁，调用空参的 tryLock（上面已经介绍过这条调用链）</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="type">long</span> <span class="variable">awaitTime</span> <span class="operator">=</span> Math.min(lockWaitTime, remainTime); <span class="comment">// 否则，较小值作为等待时间</span></span><br><span class="line">                  lockAcquired = lock.tryLock(awaitTime, newLeaseTime, TimeUnit.MILLISECONDS);  <span class="comment">// 获取锁</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (RedisResponseTimeoutException e) &#123;</span><br><span class="line">              unlockInner(Arrays.asList(lock));</span><br><span class="line">              lockAcquired = <span class="literal">false</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              lockAcquired = <span class="literal">false</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (lockAcquired) &#123;  <span class="comment">// 如果获取锁成功</span></span><br><span class="line">              acquiredLocks.add(lock);  <span class="comment">// 加入到 acquiredLocks 中</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取锁失败</span></span><br><span class="line">              <span class="keyword">if</span> (locks.size() - acquiredLocks.size() == failedLocksLimit()) &#123;  <span class="comment">// 如果失败数量等于允许的失败限制</span></span><br><span class="line">                  <span class="keyword">break</span>; <span class="comment">// 跳出循环，表示获取锁成功</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (failedLocksLimit == <span class="number">0</span>) &#123;  <span class="comment">// 如果不允许失败</span></span><br><span class="line">                  unlockInner(acquiredLocks);  <span class="comment">// 释放所有以获取的锁</span></span><br><span class="line">                  <span class="keyword">if</span> (waitTime == -<span class="number">1</span>) &#123;  <span class="comment">// 如果不进行失败重试</span></span><br><span class="line">                      <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 直接返回 false</span></span><br><span class="line">                  &#125; </span><br><span class="line">                  <span class="comment">// 如果进行失败重试</span></span><br><span class="line">                  failedLocksLimit = failedLocksLimit(); </span><br><span class="line">                  acquiredLocks.clear();  <span class="comment">// 清空集合</span></span><br><span class="line">                  <span class="comment">// reset iterator</span></span><br><span class="line">                  <span class="keyword">while</span> (iterator.hasPrevious()) &#123;  <span class="comment">// 将迭代器重置到第一个位置</span></span><br><span class="line">                      iterator.previous();</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">// 接着循环，再从第一个开始获取锁</span></span><br><span class="line">             </span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果允许失败</span></span><br><span class="line">                  failedLocksLimit--;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          <span class="keyword">if</span> (remainTime != -<span class="number">1</span>) &#123;  </span><br><span class="line">              remainTime -= System.currentTimeMillis() - time;</span><br><span class="line">              time = System.currentTimeMillis();</span><br><span class="line">              <span class="keyword">if</span> (remainTime &lt;= <span class="number">0</span>) &#123; <span class="comment">// 如果已经用完了剩余时间</span></span><br><span class="line">                  unlockInner(acquiredLocks);  <span class="comment">// 释放所有以获取的锁</span></span><br><span class="line">                  <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 返回 false</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">// for 循环外</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (leaseTime != -<span class="number">1</span>) &#123;  <span class="comment">// 如果设置了 leaseTime</span></span><br><span class="line">          List&lt;RFuture&lt;Boolean&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(acquiredLocks.size());</span><br><span class="line">          <span class="keyword">for</span> (RLock rLock : acquiredLocks) &#123;   <span class="comment">// 则给每一个节点的锁都重新设置 ttl</span></span><br><span class="line">              RFuture&lt;Boolean&gt; future = ((RedissonLock) rLock).expireAsync(unit.toMillis(leaseTime), TimeUnit.MILLISECONDS);</span><br><span class="line">              futures.add(future);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果没设置，则会开启看门狗机制（见之前的源码）</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 暂不知有什么用</span></span><br><span class="line">          <span class="keyword">for</span> (RFuture&lt;Boolean&gt; rFuture : futures) &#123;</span><br><span class="line">              rFuture.syncUninterruptibly();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 获取锁成功返回 true</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>问题解决方案：</strong></p>
<ul>
<li><p><strong>可重入</strong>：利用hash结构记录线程id和重入次数</p>
</li>
<li><p><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</p>
<blockquote>
<p>需要设置锁的等待时间。<code>tryLock(waitTime, TimeUnit)</code></p>
</blockquote>
</li>
<li><p><strong>超时续约</strong>：利用watchDog，每隔一段时间（releaseTime / 3），重置超时时间</p>
<blockquote>
<p>不可以设置锁的释放时间或设置为 -1，才能开启 watchDog。<code>tryLock(waitTime, -1, TimeUnit)</code> </p>
</blockquote>
</li>
<li><p><strong>主从一致性</strong>：利用多个独立redis节点代替主从，所有节点都获取锁成功才算获取锁成功。</p>
</li>
</ul>
<p><strong>不可重入Redis分布式锁：</strong></p>
<ul>
<li><p>原理：利用setnx的互斥性；利用ex避免死锁；释放锁时判断线程标示</p>
</li>
<li><p>缺陷：不可重入、无法重试、锁超时失效</p>
</li>
</ul>
<p><strong>可重入的Redis分布式锁：</strong></p>
<ul>
<li><p>原理：利用hash结构，记录线程标示和重入次数；利用watchDog延续锁时间；利用信号量控制锁重试等待</p>
</li>
<li><p>缺陷：redis宕机引起锁失效问题</p>
</li>
</ul>
<p><strong>Redisson的multiLock：</strong></p>
<ul>
<li>原理：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功。</li>
<li>缺陷：运维成本高、实现复杂</li>
</ul>
<h1 id="优化秒杀业务"><a href="#优化秒杀业务" class="headerlink" title="优化秒杀业务"></a>优化秒杀业务</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前实现的优惠卷秒杀业务，经过压力测试，发现性能非常的差：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271225145.png" alt="image-20220427122523078"></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271224216.png" alt="image-20220427122455133"></p>
<p>首先因为数据库和redis都搭建在云服务器上，其次是频繁的对数据库进行写操作是非常耗时的，最重要的是我们目前的秒杀业务流程是<strong>串行执行</strong>的，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271227117.png" alt="image-20220427122747991"></p>
<p>通过观察串行执行链可以发现，在正式减扣库存和创建订单前，我们首先要校验用户是否有购买权限，如果有才允许用户下单。下单最终必须将数据更新至数据库，这非常消耗时间，所以我们可以在校验用户具备购买权限后，将订单的信息放在消息队列中，使用一个异步线程来读取订单信息，并更新数据库。而校验用户购买权限只涉及到读操作，我们可以将这些信息存放在redis中，这样对系统性能的提示就更加明显，如下图：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271300239.png" alt="image-20220427130003105"></p>
<p>优化后的秒杀流程如下：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271300117.png" alt="image-20220427130046000"></p>
<h2 id="优化秒杀业务-1"><a href="#优化秒杀业务-1" class="headerlink" title="优化秒杀业务"></a>优化秒杀业务</h2><p>需求：</p>
<ol>
<li><p>新增秒杀优惠券的同时，将优惠券保存到Redis中</p>
</li>
<li><p>基于Lua脚本，判断秒杀库存、一人一单，决定用户是否抢购成功</p>
</li>
<li><p>如果抢购成功，将优惠券id和用户id封装后存入阻塞队列</p>
</li>
<li><p>开启线程任务，不断从阻塞队列中获取信息，实现下单功能</p>
</li>
</ol>
<h3 id="优惠卷信息保存到Redis中"><a href="#优惠卷信息保存到Redis中" class="headerlink" title="优惠卷信息保存到Redis中"></a>优惠卷信息保存到Redis中</h3><p>格式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stockKey <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    stock<span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">    beginTime<span class="punctuation">:</span> <span class="punctuation">&#123;</span>timestamp<span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    endTime<span class="punctuation">:</span> <span class="punctuation">&#123;</span>timestamp<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>自定义Json格式化器：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// spring.jackson.date-format=yyyy-MM-dd HH:mm:ss</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title function_">customizeLocalDateTimeFormat</span><span class="params">(<span class="meta">@Value(&quot;$&#123;spring.jackson.date-format&#125;&quot;)</span> String pattern)</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> jacksonObjectMapperBuilder -&gt; &#123;</span><br><span class="line">           <span class="type">DateTimeFormatter</span> <span class="variable">formatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(pattern);</span><br><span class="line">           jacksonObjectMapperBuilder.serializerByType(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(formatter));</span><br><span class="line">           jacksonObjectMapperBuilder.deserializerByType(LocalDateTime.class, <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(formatter));</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Controller：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/voucher&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IVoucherService voucherService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增秒杀券</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucher 优惠券信息，包含秒杀信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 优惠券id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/seckill&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">addSeckillVoucher</span><span class="params">(<span class="meta">@RequestBody</span> Voucher voucher)</span> &#123;</span><br><span class="line">        voucherService.addSeckillVoucher(voucher);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(voucher.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Service：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@Transactional</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">      <span class="comment">// 保存优惠券</span></span><br><span class="line">      save(voucher);</span><br><span class="line">      <span class="comment">// 保存秒杀信息到数据库</span></span><br><span class="line">      <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">      BeanUtil.copyProperties(voucher, seckillVoucher);</span><br><span class="line">      seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">      seckillVoucherService.save(seckillVoucher);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 保存优惠卷库存到Redis</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">stockKey</span> <span class="operator">=</span> SECKILL_STOCK_PREFIX + voucher.getId();</span><br><span class="line">      stringRedisTemplate.opsForHash().put(stockKey, <span class="string">&quot;stock&quot;</span>, voucher.getStock().toString());</span><br><span class="line">      stringRedisTemplate.opsForHash().put(stockKey, <span class="string">&quot;beginTime&quot;</span>, voucher.getBeginTime().toString());</span><br><span class="line">      stringRedisTemplate.opsForHash().put(stockKey, <span class="string">&quot;endTime&quot;</span>, voucher.getEndTime().toString());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用PostMan测试接口，新增秒杀优惠卷：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271558182.png" alt="image-20220427155845054"></p>
<p><strong>数据库：</strong></p>
<ul>
<li><code>tb_voucher</code>  表：</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271748108.png" alt="image-20220427174815995"></p>
<ul>
<li><code>tb_seckill_voucher</code>表：</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271748394.png" alt="image-20220427174803309"></p>
<p><strong>redis：</strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204271747922.png" alt="image-20220427174752820"></p>
<h3 id="秒杀-Lua-脚本"><a href="#秒杀-Lua-脚本" class="headerlink" title="秒杀 Lua 脚本"></a>秒杀 Lua 脚本</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. ARGV</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>] <span class="comment">-- 优惠卷id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>] <span class="comment">-- 用户id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. KEYS</span></span><br><span class="line"><span class="keyword">local</span> voucherKey = <span class="string">&#x27;seckill:voucher:&#x27;</span> .. voucherId  <span class="comment">-- 秒杀优惠卷key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId  <span class="comment">-- 秒杀订单key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 判断秒杀优惠卷信息是否完整</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">not</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, voucherKey, <span class="string">&#x27;stock&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">        redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, voucherKey, <span class="string">&#x27;beginTime&#x27;</span>) <span class="keyword">and</span></span><br><span class="line">        redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, voucherKey, <span class="string">&#x27;endTime&#x27;</span>))) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">-- 不完整返回 -1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 判断秒杀是否在进行中</span></span><br><span class="line"><span class="comment">-- 4.1 判断秒杀是否开始</span></span><br><span class="line"><span class="keyword">local</span> curr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, voucherKey, <span class="string">&#x27;beginTime&#x27;</span>)) &gt; <span class="built_in">tonumber</span>(curr)) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">-- 尚未开启返回 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 4.2 判断秒杀是否结束</span></span><br><span class="line">curr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, voucherKey, <span class="string">&#x27;endTime&#x27;</span>)) &lt; <span class="built_in">tonumber</span>(curr)) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>  <span class="comment">-- 已经结束返回 2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, voucherKey, <span class="string">&#x27;stock&#x27;</span>)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> <span class="comment">-- 库存不足返回 3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 判断用户是否已经购买</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;SISMEMBER&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> <span class="comment">-- 已经购买过返回 4</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7. 校验完成，下单</span></span><br><span class="line"><span class="comment">-- 7.1 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, voucherKey, <span class="string">&#x27;stock&#x27;</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 7.2 保存购买信息</span></span><br><span class="line">redis.call(<span class="string">&#x27;SADD&#x27;</span>, orderKey, userId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="comment">-- 下单成功返回 0</span></span><br></pre></td></tr></table></figure>
<h3 id="基于阻塞队列完成异步下单功能"><a href="#基于阻塞队列完成异步下单功能" class="headerlink" title="基于阻塞队列完成异步下单功能"></a>基于阻塞队列完成异步下单功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderMapper voucherOrderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdGenerator redisIdGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 UNLOCK_SCRIPT</span></span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置脚本文件的位置</span></span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/seckill.lua&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置脚本文件的返回值</span></span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载完毕后执行</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建订单异步任务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1.获取队列中的订单信息</span></span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> orderTasks.take();</span><br><span class="line">                    <span class="comment">// 2.创建订单</span></span><br><span class="line">                    createOrder(voucherOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;处理订单异常&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 秒杀优惠卷</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 1. 执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">res</span> <span class="operator">=</span> redisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(), voucherId.toString(), userId.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 下单失败</span></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动尚未开始&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动已经结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在的优惠卷&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下单成功</span></span><br><span class="line">        <span class="comment">// 2. 将订单信息保存到消息队列</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.1 设置订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.2 设置用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.3 设置优惠卷id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> JSONUtil.toJsonStr(voucherOrder);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;hmdianping.voucher&quot;</span>, <span class="string">&quot;seckill&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回订单ID</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建订单</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取 Redisson 提供的可重入锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + ORDER_PREFIX + userId;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="comment">// 2. 尝试加锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 2.1 如果获取锁失败，则当前用户已经获取了分布式锁，纪律错误信息。</span></span><br><span class="line">            log.error(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 3. 判断用户是否已经参加过活动</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已经参加过活动</span></span><br><span class="line">                log.error(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().</span><br><span class="line">                    setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                    .update();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 创建订单</span></span><br><span class="line">            voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><strong>秒杀业务的优化思路是什么？</strong></p>
<ul>
<li><p>先利用Redis完成库存判断</p>
</li>
<li><p>再将下单业务放入阻塞队列，利用独立线程异步下单</p>
</li>
</ul>
<p><strong>基于阻塞队列的异步秒杀存在哪些问题？</strong></p>
<p>阻塞队列是基于<strong>JVM内存</strong>实现的，存在以下问题：</p>
<ul>
<li><p>内存有限，任务堆积问题</p>
</li>
<li><p>持久化问题</p>
</li>
<li><p>任务丢失问题</p>
</li>
</ul>
<p>为了解决上述问题，可以使用消息队列模型实现异步秒杀功能。</p>
<h2 id="Redis消息队列实现异步秒杀"><a href="#Redis消息队列实现异步秒杀" class="headerlink" title="Redis消息队列实现异步秒杀"></a>Redis消息队列实现异步秒杀</h2><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p><strong>消息队列</strong>（<strong>M</strong>essage <strong>Q</strong>ueue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li><p>消息队列：存储消息</p>
</li>
<li><p>生产者：发送消息到消息队列</p>
</li>
<li><p>消费者：从消息队列获取消息并处理消息</p>
</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204282331579.png" alt="image-20220428233157499"></p>
<p>Redis提供了三种不同的方式来实现消息队列：</p>
<ul>
<li><p>list结构：基于List结构模拟消息队列</p>
</li>
<li><p>PubSub：基本的点对点消息模型</p>
</li>
<li><p>Stream：比较完善的消息队列模型</p>
</li>
</ul>
<h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h3><p><strong>消息队列</strong>（<strong>M</strong>essage <strong>Q</strong>ueue），字面意思就是存放消息的队列。而Redis的list数据结构是一个<strong>双向链表</strong>，很容易模拟出队列效果。</p>
<p>队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP来实现。</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204282343752.gif" alt="mq"></p>
<p>不过要注意的是，当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用<strong>BRPOP</strong>或者<strong>BLOPO</strong>来实现阻塞效果。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cr4y1671t?p=73">简单使用教程（几分钟的视频）</a></p>
<p><strong>基于List的消息队列有哪些优缺点？</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li><p>利用Redis存储，不受限于JVM内存上限</p>
</li>
<li><p>基于Redis的持久化机制，数据安全性有保证</p>
</li>
<li><p>可以满足消息有序性</p>
</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li><p>无法避免消息丢失（BRPOP 或 BLOPO 会删除消息并返回）</p>
</li>
<li><p>只支持单消费者</p>
</li>
</ul>
</li>
</ul>
<h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p><strong>PubSub（发布订阅）</strong>是Redis2.0版本引入的消息传递模型。顾名思义，<strong>消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</strong>。</p>
<ul>
<li><p><code>SUBSCRIBE channel [channel]</code> ：订阅一个或多个频道</p>
</li>
<li><p><code>PUBLISH channel msg</code> ：向一个频道发送消息</p>
</li>
<li><p><code>PSUBSCRIBE pattern[pattern]</code> ：订阅与pattern格式匹配的所有频道</p>
</li>
</ul>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204290003287.gif" alt="mq1"></p>
<p><strong>基于PubSub的消息队列有哪些优缺点？</strong></p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>采用发布订阅模型，支持多生产、多消费</li>
</ul>
</li>
<li><p><strong>缺点：</strong></p>
<ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
</li>
</ul>
<blockquote>
<p> 对于可靠性要求高的业务，不建议使用<strong>PubSub</strong></p>
</blockquote>
<h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream 是 Redis 5.0 引入的一种新<strong>数据类型</strong>，是一个功能比较完善的消息队列。</p>
<p><strong>发送消息的命令：<code>XADD</code></strong> </p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204290006752.png" alt="image-20220429000625668"></p>
<p>例如：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204290006681.png" alt="image-20220429000634606"></p>
<p><strong>读取消息的方式之一：<code>XREAD</code></strong></p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204290008833.png" alt="image-20220429000802735"></p>
<p>例如：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204290008838.png" alt="image-20220429000814758"></p>
<p><code>XREAD</code> 阻塞方式，读取最新的消息：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101731.png" alt="image-20220429105127211"></p>
<p>在业务开发中，我们可以循环的调用XREAD阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101531.png" alt="image-20220429105148550"></p>
<p>S<strong>TREAM类型消息队列的XREAD命令特点：</strong></p>
<ul>
<li><p>消息可回溯</p>
</li>
<li><p>一个消息可以被多个消费者读取</p>
</li>
<li><p>可以阻塞读取</p>
</li>
<li><p><strong>有消息漏读的风险</strong></p>
</li>
</ul>
<h3 id="基于Stream的消息队列-—-消费者组"><a href="#基于Stream的消息队列-—-消费者组" class="headerlink" title="基于Stream的消息队列 — 消费者组"></a>基于Stream的消息队列 — 消费者组</h3><p><strong>消费者组（Consumer Group）</strong>：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101701.png" alt="image-20220429105706998"></p>
<p>创建消费者组：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101361.png" alt="image-20220429105722620"></p>
<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，$代表队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其它常见命令：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101371.png" alt="image-20220429105729839"></p>
<p>从消费者组读取消息：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101552.png" alt="image-20220429105811820"></p>
<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定队列名称</li>
<li>ID：获取消息的起始ID：</li>
<li>“&gt;”：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul>
<p>消费者组监听消息的基本思路：</p>
<p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291101368.png" alt="image-20220429105848087"></p>
<p><strong>STREAM类型消息队列的XREADGROUP命令特点：</strong></p>
<ul>
<li><p>消息可回溯</p>
</li>
<li><p>一个消息可以只能被一个消费者读取</p>
</li>
<li><p>可以阻塞读取</p>
</li>
<li><p>没有消息漏读的风险</p>
</li>
<li><p>有消息确认机制，保证消息至少被消费一次</p>
</li>
</ul>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/202204291133445.png" alt="image-20220429113345293"></p>
<h2 id="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"><a href="#基于Redis的Stream结构作为消息队列，实现异步秒杀下单" class="headerlink" title="基于Redis的Stream结构作为消息队列，实现异步秒杀下单"></a>基于Redis的Stream结构作为消息队列，实现异步秒杀下单</h2><ol>
<li>创建一个Stream类型的消息队列，名为stream.orders</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE stream.orders g1 0 MKSTREAM</span><br></pre></td></tr></table></figure>
<ol>
<li>修改之前的秒杀下单Lua脚本，在认定有抢购资格后，直接向stream.orders中添加消息，内容包含voucherId和userId</li>
</ol>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. ARGV</span></span><br><span class="line"><span class="keyword">local</span> voucherId = ARGV[<span class="number">1</span>] <span class="comment">-- 优惠卷id</span></span><br><span class="line"><span class="keyword">local</span> userId = ARGV[<span class="number">2</span>] <span class="comment">-- 用户id</span></span><br><span class="line"><span class="keyword">local</span> orderId = ARGV[<span class="number">3</span>] <span class="comment">-- 订单id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. KEYS</span></span><br><span class="line"><span class="keyword">local</span> voucherKey = <span class="string">&#x27;seckill:voucher:&#x27;</span> .. voucherId  <span class="comment">-- 秒杀优惠卷key</span></span><br><span class="line"><span class="keyword">local</span> orderKey = <span class="string">&#x27;seckill:order:&#x27;</span> .. voucherId  <span class="comment">-- 秒杀订单key</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 判断秒杀优惠卷信息是否完整</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, voucherKey, <span class="string">&#x27;stock&#x27;</span>) == <span class="number">0</span> <span class="keyword">or</span></span><br><span class="line">        redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, voucherKey, <span class="string">&#x27;beginTime&#x27;</span>) == <span class="number">0</span> <span class="keyword">or</span></span><br><span class="line">        redis.call(<span class="string">&#x27;HEXISTS&#x27;</span>, voucherKey, <span class="string">&#x27;endTime&#x27;</span>) == <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">-- 不完整返回 -1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 判断秒杀是否在进行中</span></span><br><span class="line"><span class="comment">-- 4.1 判断秒杀是否开始</span></span><br><span class="line"><span class="keyword">local</span> curr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, voucherKey, <span class="string">&#x27;beginTime&#x27;</span>)) &gt; <span class="built_in">tonumber</span>(curr)) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>  <span class="comment">-- 尚未开启返回 1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">-- 4.2 判断秒杀是否结束</span></span><br><span class="line">curr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, voucherKey, <span class="string">&#x27;endTime&#x27;</span>)) &lt; <span class="built_in">tonumber</span>(curr)) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>  <span class="comment">-- 已经结束返回 2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 判断库存是否充足</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, voucherKey, <span class="string">&#x27;stock&#x27;</span>)) &lt;= <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> <span class="comment">-- 库存不足返回 3</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 6. 判断用户是否已经购买</span></span><br><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;SISMEMBER&#x27;</span>, orderKey, userId) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> <span class="comment">-- 已经购买过返回 4</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7. 校验完成，下单</span></span><br><span class="line"><span class="comment">-- 7.1 扣减库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, voucherKey, <span class="string">&#x27;stock&#x27;</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">-- 7.2 保存购买信息</span></span><br><span class="line">redis.call(<span class="string">&#x27;SADD&#x27;</span>, orderKey, userId)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 7.3 向消息队列中添加订单消息（voucherId, userId, orderId）</span></span><br><span class="line">redis.call(<span class="string">&#x27;XADD&#x27;</span>, <span class="string">&#x27;stream.orders&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;voucherId&#x27;</span>, voucherId, <span class="string">&#x27;userId&#x27;</span>, userId, <span class="string">&#x27;id&#x27;</span>, orderId)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> <span class="comment">-- 下单成功返回 0</span></span><br></pre></td></tr></table></figure>
<ol>
<li>项目启动时，开启一个线程任务，尝试获取stream.orders中的消息，完成下单</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderMapper voucherOrderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdGenerator redisIdGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 UNLOCK_SCRIPT</span></span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置脚本文件的位置</span></span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/seckillWithStream.lua&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置脚本文件的返回值</span></span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">SECKILL_ORDER_EXECUTOR</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        SECKILL_ORDER_EXECUTOR.submit(<span class="keyword">new</span> <span class="title class_">VoucherOrderHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderHandler</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">stream</span> <span class="operator">=</span> <span class="string">&quot;stream.orders&quot;</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 获取 Stream 中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders &gt;</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = redisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>).block(Duration.ofMillis(<span class="number">2000</span>)),</span><br><span class="line">                            StreamOffset.create(stream, ReadOffset.lastConsumed())  <span class="comment">//  ReadOffset.lastConsumed() 代表:  &quot;&gt;&quot;</span></span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 1.1 Stream中未读取到消息，继续循环</span></span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 1.2 读取到消息，解析对象</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; beanMap = list.get(<span class="number">0</span>).getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(beanMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 2. 异步创建订单</span></span><br><span class="line">                    createOrderAsync(voucherOrder);</span><br><span class="line">                    <span class="comment">// 3. 创建成功确认消息  XACK stream.orders g1 id</span></span><br><span class="line">                    redisTemplate.opsForStream().acknowledge(stream, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 出现异常，从 pending-list 中取未确认的消息进行处理</span></span><br><span class="line">                    log.error(<span class="string">&quot;处理 Redis Stream 消息时出现异常: &#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">                    handlePendingList(stream);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 处理Pending List中未确认的信息</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handlePendingList</span><span class="params">(String stream)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 1. 获取 Pending List 中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS stream.orders 0</span></span><br><span class="line">                    List&lt;MapRecord&lt;String, Object, Object&gt;&gt; list = redisTemplate.opsForStream().read(</span><br><span class="line">                            Consumer.from(<span class="string">&quot;g1&quot;</span>, <span class="string">&quot;c1&quot;</span>),</span><br><span class="line">                            StreamReadOptions.empty().count(<span class="number">1</span>),</span><br><span class="line">                            StreamOffset.create(stream, ReadOffset.from(<span class="string">&quot;0&quot;</span>))  <span class="comment">//  ReadOffset.from(&quot;0&quot;) 从Pending List中取第一条消息</span></span><br><span class="line">                    );</span><br><span class="line">                    <span class="comment">// 1.1 未读取到消息，直接退出</span></span><br><span class="line">                    <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 1.2 读取到消息，解析对象</span></span><br><span class="line">                    MapRecord&lt;String, Object, Object&gt; record = list.get(<span class="number">0</span>);</span><br><span class="line">                    Map&lt;Object, Object&gt; beanMap = list.get(<span class="number">0</span>).getValue();</span><br><span class="line">                    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> BeanUtil.fillBeanWithMap(beanMap, <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>(), <span class="literal">true</span>);</span><br><span class="line">                    <span class="comment">// 2. 异步创建订单</span></span><br><span class="line">                    createOrderAsync(voucherOrder);</span><br><span class="line">                    <span class="comment">// 3. 创建成功确认消息  XACK stream.orders g1 id</span></span><br><span class="line">                    redisTemplate.opsForStream().acknowledge(stream, <span class="string">&quot;g1&quot;</span>, record.getId());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">// 出现异常，纪录错误信息，继续循环</span></span><br><span class="line">                    log.error(<span class="string">&quot;处理 Pending List 消息时出现异常[&#123;&#125;]: &#123;&#125;&quot;</span>, ++count, e.getMessage());</span><br><span class="line">                    <span class="keyword">if</span> (count &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interruptedException) &#123;</span><br><span class="line">                        interruptedException.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于 Redis Stream 消息队列异步创建订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrderAsync</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 获取属性</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line">        <span class="comment">// 2. 获取 Redisson 提供的可重入锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + ORDER_PREFIX + userId;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="comment">// 3. 尝试加锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 3.1 如果获取锁失败，则当前用户已经获取了分布式锁，纪律错误信息。</span></span><br><span class="line">            log.error(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 判断用户是否已经参加过活动</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已经参加过活动</span></span><br><span class="line">                log.error(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().</span><br><span class="line">                    setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                    .update();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 创建订单</span></span><br><span class="line">            voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基于Redis Stream 实现异步秒杀下单功能</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voucherId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">res</span> <span class="operator">=</span> redisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(), voucherId.toString(), userId.toString(), orderId.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下单成功</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下单失败</span></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动尚未开始&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动已经结束&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在的优惠卷&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="基于SpringAMQP完成异步下单功能"><a href="#基于SpringAMQP完成异步下单功能" class="headerlink" title="基于SpringAMQP完成异步下单功能"></a>基于SpringAMQP完成异步下单功能</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VoucherOrderServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;VoucherOrderMapper, VoucherOrder&gt; <span class="keyword">implements</span> <span class="title class_">IVoucherOrderService</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISeckillVoucherService seckillVoucherService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> VoucherOrderMapper voucherOrderMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisIdGenerator redisIdGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 秒杀脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化 UNLOCK_SCRIPT</span></span><br><span class="line">        SECKILL_SCRIPT = <span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置脚本文件的位置</span></span><br><span class="line">        SECKILL_SCRIPT.setLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;static/seckill.lua&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置脚本文件的返回值</span></span><br><span class="line">        SECKILL_SCRIPT.setResultType(Long.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">        <span class="comment">// 1. 执行lua脚本</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">res</span> <span class="operator">=</span> redisTemplate.execute(SECKILL_SCRIPT,</span><br><span class="line">                Collections.emptyList(), voucherId.toString(), userId.toString());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 下单失败</span></span><br><span class="line">            <span class="keyword">if</span> (res == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动尚未开始&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀活动已经结束&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;不能重复下单&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Result.fail(<span class="string">&quot;不存在的优惠卷&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下单成功</span></span><br><span class="line">        <span class="comment">// 2. 将订单信息保存到消息队列</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">        <span class="comment">// 2.1 设置订单id</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdGenerator.nextId(ORDER_PREFIX);</span><br><span class="line">        voucherOrder.setId(orderId);</span><br><span class="line">        <span class="comment">// 2.2 设置用户id</span></span><br><span class="line">        voucherOrder.setUserId(userId);</span><br><span class="line">        <span class="comment">// 2.3 设置优惠卷id</span></span><br><span class="line">        voucherOrder.setVoucherId(voucherId);</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> JSONUtil.toJsonStr(voucherOrder);</span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;hmdianping.voucher&quot;</span>, <span class="string">&quot;seckill&quot;</span>, msg);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 返回订单ID</span></span><br><span class="line">        <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 RabbitMQ 异步创建订单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@RabbitListener(bindings = &#123;</span></span><br><span class="line"><span class="meta">            @QueueBinding(</span></span><br><span class="line"><span class="meta">                    value = @Queue(&quot;voucher.seckill&quot;),</span></span><br><span class="line"><span class="meta">                    exchange = @Exchange(name = &quot;hmdianping.voucher&quot;, type = &quot;direct&quot;),</span></span><br><span class="line"><span class="meta">                    key = &#123;&quot;seckill&quot;&#125;</span></span><br><span class="line"><span class="meta">            )</span></span><br><span class="line"><span class="meta">    &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 反序列化 msg 为 voucherOrder</span></span><br><span class="line">        <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> JSONUtil.toBean(msg, VoucherOrder.class);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">        <span class="type">Long</span> <span class="variable">voucherId</span> <span class="operator">=</span> voucherOrder.getVoucherId();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取 Redisson 提供的可重入锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_PREFIX + ORDER_PREFIX + userId;</span><br><span class="line">        <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(lockKey);</span><br><span class="line">        <span class="comment">// 3. 尝试加锁</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isLock) &#123;</span><br><span class="line">            <span class="comment">// 3.1 如果获取锁失败，则当前用户已经获取了分布式锁，纪律错误信息。</span></span><br><span class="line">            log.error(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 4. 判断用户是否已经参加过活动</span></span><br><span class="line">            <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 用户已经参加过活动</span></span><br><span class="line">                log.error(<span class="string">&quot;不能重复参加活动&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 扣减库存</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update().</span><br><span class="line">                    setSql(<span class="string">&quot;stock = stock - 1&quot;</span>)</span><br><span class="line">                    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId)</span><br><span class="line">                    .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>)</span><br><span class="line">                    .update();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 5. 创建订单</span></span><br><span class="line">            voucherOrderMapper.saveVoucherOrder(voucherOrder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://yrc030.github.io">庸人冲</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://yrc030.github.io/posts/390cb8c9/">https://yrc030.github.io/posts/390cb8c9/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yrc030.github.io" target="_blank">庸人冲的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/f9e012fb/"><img class="next-cover" src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MybatisPlus字段自动填充失效，填充值为NULL的一种解决方法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/b51c2b76/" title="JS 面向对象编程"><img class="cover" src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-01</div><div class="title">JS 面向对象编程</div></div></a></div><div><a href="/posts/b2a734ffj/" title="ES6 语法教程"><img class="cover" src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-27</div><div class="title">ES6 语法教程</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">庸人冲</div><div class="author-info__description">纪录工作、学习、生活</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Yrc030"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Yrc030" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1030104176@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AE%89%E8%A3%85"><span class="toc-number">1.</span> <span class="toc-text">Redis概述和安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C"><span class="toc-number">1.4.</span> <span class="toc-text">运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%97%AD"><span class="toc-number">1.5.</span> <span class="toc-text">关闭</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">1.6.</span> <span class="toc-text">Redis相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%BA%93%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-number">1.6.1.</span> <span class="toc-text">默认库及相关指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">1.6.2.</span> <span class="toc-text">单线程 + 多路IO复用技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Key%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">Key相关命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">常用五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String"><span class="toc-number">3.1.</span> <span class="toc-text">String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">3.2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-1"><span class="toc-number">3.2.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set"><span class="toc-number">3.3.</span> <span class="toc-text">Set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">3.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-2"><span class="toc-number">3.3.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash"><span class="toc-number">3.4.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-3"><span class="toc-number">3.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-3"><span class="toc-number">3.4.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Zset%EF%BC%88%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">Zset（有序集合）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-4"><span class="toc-number">3.5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-4"><span class="toc-number">3.5.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">4.</span> <span class="toc-text">Redis的发布和订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85"><span class="toc-number">4.1.</span> <span class="toc-text">什么是发布和订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85-1"><span class="toc-number">4.2.</span> <span class="toc-text">Redis的发布和订阅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">发布订阅指令实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Redis 新数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Bitmpas"><span class="toc-number">5.1.</span> <span class="toc-text">Bitmpas</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-5"><span class="toc-number">5.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-5"><span class="toc-number">5.1.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HyperLogLog"><span class="toc-number">5.2.</span> <span class="toc-text">HyperLogLog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-6"><span class="toc-number">5.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-6"><span class="toc-number">5.2.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Geospatial"><span class="toc-number">5.3.</span> <span class="toc-text">Geospatial</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-7"><span class="toc-number">5.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4-7"><span class="toc-number">5.3.2.</span> <span class="toc-text">常用指令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jedis"><span class="toc-number">6.</span> <span class="toc-text">Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis-%E8%BF%9E%E6%8E%A5%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.1.</span> <span class="toc-text">Jedis 连接与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis-%E8%BF%9E%E6%8E%A5"><span class="toc-number">6.1.1.</span> <span class="toc-text">Jedis 连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">6.1.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Jedis-API"><span class="toc-number">6.2.</span> <span class="toc-text">Jedis API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RedisTemplate"><span class="toc-number">7.</span> <span class="toc-text">RedisTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">7.1.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">7.2.1.</span> <span class="toc-text">默认序列化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8"><span class="toc-number">7.2.2.</span> <span class="toc-text">自定义序列化器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringRedisTemplate"><span class="toc-number">7.3.</span> <span class="toc-text">StringRedisTemplate</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1"><span class="toc-number">8.</span> <span class="toc-text">Redis 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">Redis 事务定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">Redis 事务指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">Redis 事务的错误处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%EF%BC%88%E9%94%81%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">Redis 事务冲突解决（锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">8.4.1.</span> <span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">8.4.2.</span> <span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%B9%90%E8%A7%82%E9%94%81%E6%8C%87%E4%BB%A4"><span class="toc-number">8.5.</span> <span class="toc-text">Redis 乐观锁指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E4%B8%89%E7%89%B9%E6%80%A7"><span class="toc-number">8.6.</span> <span class="toc-text">Redis 事务三特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E4%BA%8B%E5%8A%A1%E7%A7%92%E6%9D%80%E6%A1%88%E4%BE%8B"><span class="toc-number">8.7.</span> <span class="toc-text">Redis 事务秒杀案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%A7%92%E6%9D%80%E8%AF%B7%E6%B1%82%E6%A8%A1%E6%8B%9F"><span class="toc-number">8.7.1.</span> <span class="toc-text">处理秒杀请求模拟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AB-%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E6%A8%A1%E6%8B%9F%E5%B9%B6%E5%8F%91"><span class="toc-number">8.7.2.</span> <span class="toc-text">AB 测试工具模拟并发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%B9%B6%E5%8F%91%E4%BA%A7%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.3.</span> <span class="toc-text">解决并发产生的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.3.1.</span> <span class="toc-text">解决超卖问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">8.7.3.2.</span> <span class="toc-text">解决超时问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98"><span class="toc-number">9.</span> <span class="toc-text">项目实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95-%E2%80%93-Redis-%E7%9A%84%E5%85%B1%E4%BA%AB-Session-%E5%BA%94%E7%94%A8"><span class="toc-number">9.1.</span> <span class="toc-text">短信登录 – Redis 的共享 Session 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.1.1.</span> <span class="toc-text">导入项目</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">项目结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.1.1.2.</span> <span class="toc-text">导入后端项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE"><span class="toc-number">9.1.1.3.</span> <span class="toc-text">导入前端项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESession%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">基于Session实现登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E9%AA%8C%E8%AF%81%E7%A0%81"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">发送验证码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98"><span class="toc-number">10.1.</span> <span class="toc-text">什么是缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98"><span class="toc-number">10.2.</span> <span class="toc-text">添加Redis缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">10.3.</span> <span class="toc-text">缓存更新策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">10.3.1.</span> <span class="toc-text">主动更新策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">10.4.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">10.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">10.4.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">10.4.2.1.</span> <span class="toc-text">缓存空对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.4.2.2.</span> <span class="toc-text">布隆过滤器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">10.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">10.5.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">10.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">10.5.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">10.6.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">10.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">10.6.2.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">10.6.2.1.</span> <span class="toc-text">互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">10.6.2.2.</span> <span class="toc-text">逻辑过期时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">10.6.2.3.</span> <span class="toc-text">两种方案的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%B7%A5%E5%85%B7%E5%B0%81%E8%A3%85"><span class="toc-number">10.6.3.</span> <span class="toc-text">缓存工具封装</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80"><span class="toc-number">11.</span> <span class="toc-text">优惠卷秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">11.1.</span> <span class="toc-text">全局唯一ID</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">11.1.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80ID%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">11.1.2.</span> <span class="toc-text">全局ID生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E7%94%9F%E6%88%90%E5%85%A8%E5%B1%80ID"><span class="toc-number">11.1.3.</span> <span class="toc-text">Redis 生成全局ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">11.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%BC%98%E6%83%A0%E5%8D%B7%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">11.2.</span> <span class="toc-text">实现优惠卷秒杀下单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">超卖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">11.3.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-1"><span class="toc-number">11.3.2.</span> <span class="toc-text">乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">版本号机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CAS%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.2.2.</span> <span class="toc-text">CAS机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81-CAS-%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.3.</span> <span class="toc-text">乐观锁 CAS 解决超卖问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">11.4.</span> <span class="toc-text">一人一单</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90-2"><span class="toc-number">11.4.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%82%B2%E8%A7%82%E9%94%81%E8%A7%A3%E5%86%B3%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">11.4.2.</span> <span class="toc-text">使用悲观锁解决一人一单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95%E7%9A%84%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">11.4.3.</span> <span class="toc-text">一人一单的并发安全问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">12.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">12.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">12.2.</span> <span class="toc-text">不同实现方式的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">12.3.</span> <span class="toc-text">Redis 实现分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%80%9D%E8%B7%AF"><span class="toc-number">12.3.1.</span> <span class="toc-text">Redis实现分布式锁思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%89%88%E6%9C%AC-1"><span class="toc-number">12.3.2.</span> <span class="toc-text">Redis实现分布式锁版本 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%AF%AF%E5%88%A0%E9%97%AE%E9%A2%98"><span class="toc-number">12.3.3.</span> <span class="toc-text">分布式锁误删问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%89%88%E6%9C%AC-2"><span class="toc-number">12.3.4.</span> <span class="toc-text">Redis实现分布式锁版本 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">12.3.5.</span> <span class="toc-text">分布式锁的原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E8%A7%A3%E5%86%B3%E5%A4%9A%E6%9D%A1%E5%91%BD%E4%BB%A4%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">12.3.6.</span> <span class="toc-text">Lua脚本解决多条命令原子性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lua-%E8%B0%83%E7%94%A8redis%E5%91%BD%E4%BB%A4"><span class="toc-number">12.3.6.1.</span> <span class="toc-text">lua 调用redis命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-%E8%B0%83%E7%94%A8-lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">12.3.6.2.</span> <span class="toc-text">redis 调用 lua 脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lua%E8%84%9A%E6%9C%AC%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">12.3.6.3.</span> <span class="toc-text">Lua脚本释放锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%89%88%E6%9C%AC-3"><span class="toc-number">12.3.7.</span> <span class="toc-text">Redis实现分布式锁版本 3</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">12.3.8.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redisson"><span class="toc-number">12.4.</span> <span class="toc-text">Redisson</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.4.1.</span> <span class="toc-text">功能介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8-1"><span class="toc-number">12.4.2.</span> <span class="toc-text">快速入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson-%E7%9A%84%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">12.4.3.</span> <span class="toc-text">Redisson 的可重入锁原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-setnx-%E6%98%AF%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E7%9A%84%EF%BC%9F"><span class="toc-number">12.4.3.1.</span> <span class="toc-text">为什么 setnx 是不可重入的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">12.4.3.2.</span> <span class="toc-text">可重入锁原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">12.4.3.3.</span> <span class="toc-text">Redisson 解决不可重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redisson-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">12.4.3.4.</span> <span class="toc-text">Redisson 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson-%E7%9A%84%E9%94%81%E9%87%8D%E8%AF%95%E5%8E%9F%E7%90%86"><span class="toc-number">12.4.4.</span> <span class="toc-text">Redisson 的锁重试原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson-%E8%A7%A3%E5%86%B3%E8%B6%85%E6%97%B6%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86"><span class="toc-number">12.4.5.</span> <span class="toc-text">Redisson 解决超时释放原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisso-%E8%A7%A3%E5%86%B3%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">12.4.6.</span> <span class="toc-text">Redisso 解决主从一致性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MultiLock"><span class="toc-number">12.4.6.1.</span> <span class="toc-text">MultiLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MultiLock-%E6%BA%90%E7%A0%81"><span class="toc-number">12.4.6.2.</span> <span class="toc-text">MultiLock 源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">12.4.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1"><span class="toc-number">13.</span> <span class="toc-text">优化秒杀业务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">13.1.</span> <span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1-1"><span class="toc-number">13.2.</span> <span class="toc-text">优化秒杀业务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E6%83%A0%E5%8D%B7%E4%BF%A1%E6%81%AF%E4%BF%9D%E5%AD%98%E5%88%B0Redis%E4%B8%AD"><span class="toc-number">13.2.1.</span> <span class="toc-text">优惠卷信息保存到Redis中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80-Lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">13.2.2.</span> <span class="toc-text">秒杀 Lua 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E4%B8%8B%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">13.2.3.</span> <span class="toc-text">基于阻塞队列完成异步下单功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">13.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80"><span class="toc-number">13.3.</span> <span class="toc-text">Redis消息队列实现异步秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.3.1.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.3.2.</span> <span class="toc-text">基于List结构模拟消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.3.3.</span> <span class="toc-text">基于PubSub的消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">13.3.4.</span> <span class="toc-text">基于Stream的消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E2%80%94-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="toc-number">13.3.5.</span> <span class="toc-text">基于Stream的消息队列 — 消费者组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">13.3.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84Stream%E7%BB%93%E6%9E%84%E4%BD%9C%E4%B8%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E7%A7%92%E6%9D%80%E4%B8%8B%E5%8D%95"><span class="toc-number">13.4.</span> <span class="toc-text">基于Redis的Stream结构作为消息队列，实现异步秒杀下单</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ESpringAMQP%E5%AE%8C%E6%88%90%E5%BC%82%E6%AD%A5%E4%B8%8B%E5%8D%95%E5%8A%9F%E8%83%BD"><span class="toc-number">13.5.</span> <span class="toc-text">基于SpringAMQP完成异步下单功能</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/f91cb2a/" title="linux学习笔记.md"><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux学习笔记.md"/></a><div class="content"><a class="title" href="/posts/f91cb2a/" title="linux学习笔记.md">linux学习笔记.md</a><time datetime="2022-12-14T05:53:22.000Z" title="发表于 2022-12-14 13:53:22">2022-12-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b51c2b76/" title="JS 面向对象编程"><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JS 面向对象编程"/></a><div class="content"><a class="title" href="/posts/b51c2b76/" title="JS 面向对象编程">JS 面向对象编程</a><time datetime="2022-08-31T16:00:00.000Z" title="发表于 2022-09-01 00:00:00">2022-09-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/b2a734ffj/" title="ES6 语法教程"><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ES6 语法教程"/></a><div class="content"><a class="title" href="/posts/b2a734ffj/" title="ES6 语法教程">ES6 语法教程</a><time datetime="2022-08-26T16:00:00.000Z" title="发表于 2022-08-27 00:00:00">2022-08-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/f9e012fb/" title="MybatisPlus字段自动填充失效，填充值为NULL的一种解决方法"><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MybatisPlus字段自动填充失效，填充值为NULL的一种解决方法"/></a><div class="content"><a class="title" href="/posts/f9e012fb/" title="MybatisPlus字段自动填充失效，填充值为NULL的一种解决方法">MybatisPlus字段自动填充失效，填充值为NULL的一种解决方法</a><time datetime="2022-05-20T16:00:00.000Z" title="发表于 2022-05-21 00:00:00">2022-05-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/390cb8c9/" title="redis学习笔记"><img src="https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="redis学习笔记"/></a><div class="content"><a class="title" href="/posts/390cb8c9/" title="redis学习笔记">redis学习笔记</a><time datetime="2021-07-27T16:00:00.000Z" title="发表于 2021-07-28 00:00:00">2021-07-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://yrc-img.oss-cn-hangzhou.aliyuncs.com/img/cover2.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By 庸人冲</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><a target="_blank" rel="noopener" href="https://beian.miit.gov.cn/#/Integrated/index"><img class="icp-icon" src="https://s2.loli.net/2022/08/27/Cn7RJpi9A8qWyTo.png"><span>鄂ICP备2021019129号-2</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'lbClacQifar9rdK9gSG1GIw0-gzGzoHsz',
      appKey: 'QEmMwYLwbvM1L6ROtYBYDzqO',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: {"tv_doge":"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png","tv_亲亲":"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png","tv_偷笑":"bb690d4107620f1c15cff29509db529a73aee261.png","tv_再见":"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png","tv_冷漠":"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png","tv_发怒":"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png","tv_发财":"34db290afd2963723c6eb3c4560667db7253a21a.png","tv_可爱":"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png","tv_吐血":"09dd16a7aa59b77baa1155d47484409624470c77.png","tv_呆":"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png","tv_呕吐":"9f996894a39e282ccf5e66856af49483f81870f3.png","tv_困":"241ee304e44c0af029adceb294399391e4737ef2.png","tv_坏笑":"1f0b87f731a671079842116e0991c91c2c88645a.png","tv_大佬":"093c1e2c490161aca397afc45573c877cdead616.png","tv_大哭":"23269aeb35f99daee28dda129676f6e9ea87934f.png","tv_委屈":"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png","tv_害羞":"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png","tv_尴尬":"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png","tv_微笑":"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png","tv_思考":"90cf159733e558137ed20aa04d09964436f618a1.png","tv_惊吓":"0d15c7e2ee58e935adc6a7193ee042388adc22af.png"},
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="aplayer no-destroy" data-id="8601519705" data-server="tencent" data-type="playlist"   data-order="list" data-fixed="true" data-preload="auto" data-autoplay="false" data-mutex="true" ></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="app-refresh" id="app-refresh" style="position: fixed;top: -2.2rem;left: 0;right: 0;z-index: 99999;padding: 0 1rem;font-size: 15px;height: 2.2rem;transition: all 0.3s ease;"><div class="app-refresh-wrap" style=" display: flex;color: #fff;height: 100%;align-items: center;justify-content: center;"><label>✨ 有新文章啦！ 👉</label><a href="javascript:void(0)" onclick="location.reload()"><span style="color: #fff;text-decoration: underline;cursor: pointer;">🍗点击食用🍔</span></a></div></div><script>if ('serviceWorker' in navigator) {
if (navigator.serviceWorker.controller) {
navigator.serviceWorker.addEventListener('controllerchange', function() {
showNotification()
})
}
window.addEventListener('load', function() {
navigator.serviceWorker.register('/sw.js')
})
}
function showNotification() {
if (GLOBAL_CONFIG.Snackbar) {
var snackbarBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
GLOBAL_CONFIG.Snackbar.bgLight :
GLOBAL_CONFIG.Snackbar.bgDark
var snackbarPos = GLOBAL_CONFIG.Snackbar.position
Snackbar.show({
text: '✨ 有新文章啦！ 👉',
backgroundColor: snackbarBg,
duration: 500000,
pos: snackbarPos,
actionText: '🍗点击食用🍔',
actionTextColor: '#fff',
onActionClick: function(e) {
location.reload()
},
})
} else {
var showBg =
document.documentElement.getAttribute('data-theme') === 'light' ?
'#49b1f5' :
'#1f1f1f'
var cssText = `top: 0; background: ${showBg};`
document.getElementById('app-refresh').style.cssText = cssText
}
}</script></div><!-- hexo injector body_end start --><script async src="/js/ali_font.js"></script><!-- hexo injector body_end end --></body></html>